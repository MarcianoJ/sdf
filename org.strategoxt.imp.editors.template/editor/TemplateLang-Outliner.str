module editor/TemplateLang-Outliner

/*
 * When making changes to this code, do realise that it is being used for both the SDF2 and SDF3 editors.
 */

imports
  include/TemplateLang
  lib/outline-library.generated
  lib/runtime/editor/origins

rules
  
  outline-strategy:
    ast -> Node(label{icon}, children)
    where
      desugared := <alltd(outline-desugar)> ast;
      label := <get-module-name> desugared;
      icon :=  <icon-module>;
      sections := <collect-om(is-outline-section, conc)> desugared;
      children := <collect-om(get-outline-section); map(outline-section-to-node(|sections))> sections
      
  outline-expand-to-level = !3
  
rules
  
  outline-desugar = ?label(_, <id>)
  outline-desugar = ?unparameterized(<id>)
  outline-desugar = ?parameterized(<id>, _)
  
rules
  
  // icons
  icon-module = !"icons/module.png"
  icon-exports = !"icons/exports.png"
  icon-layout = !"icons/layout.png"
  
  outline-section-to-icon = ?Start(); !"icons/start.png"
  outline-section-to-icon = ?Lex(); !"icons/prod-lex.png"
  outline-section-to-icon = ?CF(); !"icons/prod-cf.png"
  outline-section-to-icon = ?Restriction(); !"icons/follow-restriction.png"
  
  // overlays
  icon-overlay-cons = ?path; get-extension; ?extension; !(<remove-extension> path, "-cons"); conc-strings; !(<id>, extension); add-extension
  
signature constructors
  
  Start:           OutlineSection
  Lex:             OutlineSection
  CF:              OutlineSection
  Restriction:     OutlineSection
  Other:           OutlineSection
  
rules
  
  outline-section-to-node(|sections):
    outline-section -> Node(label{icon}, children)
    where
      sections' := <collect-om(has-outline-section(|outline-section), conc)> sections;
      label := <Hd; concrete-syntax-at-start> sections';
      icon := <icon-exports>;
      children := <to-outline-nodes(|outline-section) <+ collect-om(to-outline-label(|outline-section)); map(label-to-outline-node)> sections'
  
  label-to-outline-node = ?label; !Node(label, [])
  
  get-outline-section: section -> Start()
    where <?kernel-start-symbols(_) + ?lexical-start-symbols(_) + ?context-free-start-symbols(_)> section
  get-outline-section: section -> Lex()
    where <?lexical-syntax(_) + ?syntax(_)> section
  get-outline-section: section -> CF()
    where <?context-free-syntax(_) + ?TemplateSection(_)> section
  get-outline-section: section -> Restriction()
    where <?context-free-restrictions(_)> section
  get-outline-section: section -> Other()
    where <?variables(_) + ?lexical-variables(_) + ?lexical-priorities(_) + ?context-free-priorities(_) + ?aliases(_) + ?restrictions(_) + ?TemplateOptions(_)> section
  
  is-outline-section = ?section; get-outline-section; !section
  
  has-outline-section(|outline-section) = ?section; get-outline-section; ?outline-section; !section

rules
	
  // module
  get-module-name: 'module(name, _, _) -> name
  get-module-name = ?CompilationUnit(_); origin-file
  
  // start
  to-outline-label(|outline-section):
    sort(s) -> label{icon}
    where
      Start() := outline-section;
      label := s;
      icon := <outline-section-to-icon> outline-section
  
  // lexical and context-free productions
  to-outline-nodes(|outline-section):
    sections -> nodes
    where
      <?Lex() + ?CF()> outline-section;
      'sorts := <collect-om(fetch-sort, conc); reverse; make-set; reverse> sections; // HACK => collect-om returns the last element in case of duplicates; we want the first, for its origin
      nodes := <map(sort-to-outline-node(|outline-section, sections))> 'sorts
  
  sort-to-outline-node(|outline-section, sections):
    sort -> Node(label{icon}, children)
    where
      prods := <collect-om(prod-has-sort(|sort), conc)> sections;
      label := <Hd; fetch-sort; origin-text> prods;
      if layout() := sort
      then icon := <icon-layout>
      else icon := <outline-section-to-icon> outline-section
      end;
      children := <map(prod-to-outline-node(|outline-section))> prods
  
  prod-to-outline-node(|outline-section):
  	prod -> Node(label{icon}, [])
  	where
      sort := <fetch-sort> prod;
  		if cons-name := <prod-to-cons> prod
  		then
  			label := cons-name;
  			icon := <outline-section-to-icon; icon-overlay-cons> outline-section
  	  else
        lhs := <fetch-lhs> prod;
        label := <origin-text; outline-rm-excess-whitespace> lhs;
        <origin-location-offset-set(|<origin-location-offset> lhs)> label;
        if layout() := sort
        then icon := <icon-layout>
        else icon := <outline-section-to-icon> outline-section
        end
  	  end
  
  prod-to-cons: prod(_, _, attrs) -> <fetch-cons-name> attrs
  prod-to-cons: SdfProduction(_, _, attrs) -> <fetch-cons-name> attrs
  prod-to-cons = ?TemplateProductionWithCons(SortCons(_, <id>), _, _)
  
  fetch-sort = ?prod(_, <id>, _)
  fetch-sort = ?SdfProduction(<id>, _, _)
  fetch-sort = ?TemplateProductionWithCons(SortCons(<id>, _), _, _)
  fetch-sort = ?TemplateProduction(<id>, _, _)
  
  fetch-lhs = ?prod(<id>, _, _)
  fetch-lhs = ?SdfProduction(_, <id>, _)
  fetch-lhs = ?TemplateProductionWithCons(_, <id>, _)
  fetch-lhs = ?TemplateProduction(_, <id>, _)
  
  prod-has-sort(|sort) = ?prod; fetch-sort; ?sort; !prod

  // // restrictions
  to-outline-nodes(|outline-section):
    sections -> nodes
    where
      <?Restriction()> outline-section;
      symbolss := <collect-om(fetch-symbols, conc); reverse; make-set; reverse> sections; // HACK => collect-om returns the last element in case of duplicates; we want the first, for its origin
      nodes := <map(restriction-symbols-to-outline-node(|sections))> symbolss
  
  restriction-symbols-to-outline-node(|sections):
    symbols -> Node(label{icon}, children)
    where
      restrictions := <collect-om(restriction-has-symbols(|symbols), conc)> sections;
      label := <Hd; fetch-symbols; origin-text; outline-rm-excess-whitespace> restrictions;
      icon := <outline-section-to-icon> Restriction();
      children := <map(restriction-to-outline-node)> restrictions

  restriction-to-outline-node:
    follow(_, lookaheads) -> Node(label'{icon}, [])
    where
      label := <origin-text; outline-rm-excess-whitespace> lookaheads;
      label' := <origin-track-forced(!label)> lookaheads;
      icon := <outline-section-to-icon> Restriction()

  fetch-symbols = ?follow(<id>, _)
  
  restriction-has-symbols(|symbols) = ?follow(symbols, _)

rules // utils

  concrete-syntax-at-start:
  	term -> result'
  	where
  		(cons, args) := <explode-term> term;
  		offset1 := <origin-offset; ?(<id>, _)> term;
  		offset2 := <Hd; origin-offset; ?(<id>, _)> args;
  		offset-diff := <subt> (offset2, offset1);
  		result := <origin-text; explode-string; take(!offset-diff); rtrim(is-whitespace + is-return); implode-string> term;
   		result' := <outline-rm-excess-whitespace> result;
  		(a, b, c, d, e) := <origin-location-offset> term;
  		<origin-location-offset-set(|(a, b, c, d, <add> (d, <string-length; dec> result)))> result'
  
  is-return = test('\n')
  
  outline-rm-excess-whitespace = string-as-chars(
      map(try(test('\n' + '\t'); !' '));
      foldr(![], rm-double-space <+ MkCons)
    )
    
  rm-double-space: (' ', l@[' '|xs]) -> l
  
signature constructors
  
  'module : ModuleName * List(ImpSection) * Sections -> Module
  True: Bool
  False: Bool
  
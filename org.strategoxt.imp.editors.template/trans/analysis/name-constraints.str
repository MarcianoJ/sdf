module analysis/name-constraints

imports

  include/TemplateLang
  analysis/names
  libstrc
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  analysis/types
  
  strategies
  	
  	nabl-check-disable-duplicate(|uri, ns) = id
  	nabl-check-disable-unresolved = id
  	
  	
  	nabl-constraint(|ctx):
  		sc@SortConsRef(Sort(s), Constructor(c)) -> <fail>
  		where
  			<has-annotation(?Use(task))> c;
  			msg := $[Unresolved reference to constructor '[c]' of sort '[s]'];
  			<task-create-error-on-triggers(|ctx, [Failure(task)], msg)> sc
  	
  	nabl-constraint(|ctx):
  		sc@SortConsRef(Cf(Sort(s)), Constructor(c)) -> <fail>
  		where
  			<has-annotation(?Use(task))> c;
  			msg := $[Unresolved reference to constructor '[c]' of sort '[s]'];
  			<task-create-error-on-triggers(|ctx, [Failure(task)], msg)> sc
  	
  	nabl-constraint(|ctx):
  		sc@SortConsRef(Lex(Sort(s)), Constructor(c)) -> <fail>
  		where
  			<has-annotation(?Use(task))> c;
  			msg := $[Unresolved reference to constructor '[c]' of sort '[s]'];
  			<task-create-error-on-triggers(|ctx, [Failure(task)], msg)> sc
  	
  	
  	
  	nabl-constraint(|ctx):
  		Module(Unparameterized(m)) -> <fail>
  		where
  		<has-annotation(?Use(task))> m;
  		msg := $[Unresolved reference to module '[m]'];
  		<task-create-error-on-triggers(|ctx, [Failure(task)], msg)> m
  					
  	
  	nabl-constraint(|ctx):
  		p@Placeholder(label, Sort(s), t, options) -> <fail>
  		where
  			<has-annotation(?Use(task))> s;
  			msg := $[Unresolved reference to sort '[s]'];
  			<task-create-error-on-triggers(|ctx, [Failure(task)], msg)> p
  			
  	nabl-constraint(|ctx):
  		 Sort(s) -> <fail>
  		where
  			<has-annotation(?Use(task))> s;
  			msg := $[Unresolved reference to sort '[s]'];
  			<task-create-error-on-triggers(|ctx, [Failure(task)], msg)> s
  	
  			
    nabl-constraint(|ctx):
  		SdfProductionWithCons(SortCons(s, Constructor(c)), rhs, attrs) -> <fail>
  		where
  			type       := <type-lookup(|ctx)> c;
  			lookup     := <nabl-lookup-lexical(|ctx)> c;
  			cons-types := <type-lookup(|ctx)> lookup;
  			same-types := <task-create-rewrite(|ctx, "match-sort-type")> (type, cons-types);
  			<task-create-error-on-triggers(|ctx, [Multiple(same-types)], $[Duplicated definition for constructor [c]])> c

		
	task-rewrite:
  	  ("match-sort-type", (e@FunType(ty*, SortType(s)), a@FunType(ty'*, SortType(s')))) -> a
  	  where
  	  	<?s> s';
  	  	<eq> (<length> ty*, <length> ty'*)
  	  	
 signature constructors
 	
 	MakeSet : List(Term) -> Instruction
 	
rules
	
	task-is-combinator = ?MakeSet(_)
	
	perform-task(|task-id):
		MakeSet(list) -> <make-set> list
		
	task-create-make-set(|ctx):
		list -> <new-task(|ctx)> MakeSet(list)

module analysis/normalization
imports
  libstratego-lib
  include/TemplateLang
  templatelang/utils/attributes
  templatelang/utils/contract
  templatelang/utils/misc
  runtime/editor/origins
  analysis/names
  
  
  strategies
  
  normalize-all = bottomup(try(normalize))
     
  rules
  	
  normalize: 
  	NoAttrs() -> Attrs([])
  	
  normalize:
    SdfProductionWithCons(SortCons(s, Constructor(cons)), symbols*, Attrs(a*)) ->
      SdfProductionWithCons(SortCons(s, Constructor(cons)), symbols*, Attrs(a'*))
    with
    	c   := <double-quote> cons; 
        a'* := [sdf-cons(c) , a*]
    
  normalize: 
  	TemplateProductionWithCons(SortCons(s, Constructor(cons)), template, Attrs(a*)) ->
      TemplateProductionWithCons(SortCons(s, Constructor(cons)), template, Attrs(a'*))
     with
     	c   := <double-quote> cons; 
        a'* := [sdf-cons(c) , a*]
  
  //regular sdf2 productions become sdf3 productions with or without constructors     	
  normalize:
  	Prod(symbols*, Sort(s), Attrs(a*)) -> result
  	with 
  		c := <getfirst(lift-constr)> a*;
  		result := SdfProductionWithCons(SortCons(s, c), Rhs(symbols*), Attrs(a*))
  	<+  result := SdfProduction(s, Rhs(symbols*), Attrs(a*)) 
  
  //sdf2 productions with complex symbols in the left hand side become a SymbolSdfProduction	
  normalize:
  	Prod(symbols*, symbol, Attrs(a*)) -> result
  	where 	
  		<not(?Sort(_) <+ ?Lex(Sort(_)) <+ ?Cf(Sort(_)))> symbol; //if this prod is not kernel
  		result := SymbolSdfProduction(symbol, Rhs(symbols*), Attrs(a*))
  		
  
  normalize:
  	Prod(symbols*, Lex(Sort(c)), Attrs(a*)) -> result
  	with 	
  		result := SortKernelProduction(SortLex(c), Rhs(symbols*), Attrs(a*))
  		
  normalize:
  	Prod(symbols*, Cf(Sort(c)), Attrs(a*)) -> result
  	with 	
  		result := SortKernelProduction(SortCf(c), Rhs(symbols*), Attrs(a*))		
 
  
  //normalize reductive productions section to productive productions section
  normalize:
  	Contextfree(p*) -> ContextFreeSyntax(p*)
  	
  normalize:
  	Lexical(p*) -> LexicalSyntax(p*)
  	
  normalize:
  	Syntax(p*) -> Kernel(p*)	
  	  	
  /*normalize:
  	TemplateSection(t) -> [TemplateSection(t), contentcompletion*]
  	with
  		p* := < map(?TemplateProduction(<id>, _, _) <+ ?TemplateProductionWithCons(SortCons(<id>, Constructor(_)), _, _))
             ; nub 
             ; map(sort-to-contentcomplete)> t;	
        if [] := p*
        then
        	contentcompletion* := []
        else
          contentcompletion* := [SDFSection(ContextFreeSyntax(p*))]
        end
  
  
  normalize:
  	Module(m, i, sections) -> Module(m, i, sections')
  	with
  		sections' := <flatten-list> sections
*/  
        
  /*sort-to-contentcomplete:
     sort@Sort(s) -> SdfProductionWithCons(SortCons(sort, Constructor($[COMPLETION-[s]])), [Sort("CONTENTCOMPLETE")], Attrs([sdf-cons(c)]))
     with
     	c := <double-quote> $[COMPLETION-[s]]
   */  	
     	
  //normalize:
  	//SimpleRefGroup(SortCons(sort, Constructor(c))) -> <id> //SimpleGroup(prod')
  //	with
 // 		prod' := <get-def> c
 // 		; debug(!"a")
  	
  lift-constr:
  	sdf-cons(c) -> Constructor(<un-double-quote> c)
  	
  lift-constr:
    QuotedConstructor(c) -> Constructor(<un-double-quote> c)
     
  		
  		
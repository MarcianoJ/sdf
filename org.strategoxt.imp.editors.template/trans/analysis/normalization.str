module analysis/normalization
imports
  libstratego-lib
  include/TemplateLang
  templatelang/utils/attributes
  templatelang/utils/contract
  templatelang/utils/misc
  runtime/editor/origins
  analysis/names
  
   rules
  external unquote(|)
  
  
  strategies
  
  normalize-all = bottomup(try(normalize))
     
  rules
  	
  normalize: 
  	NoAttrs() -> Attrs([])
  	
  // normalize:
  //   SdfProductionWithCons(SortCons(s, Constructor(cons)), symbols*, Attrs(a*)) ->
  //     SdfProductionWithCons(SortCons(s, Constructor(cons)), symbols*, Attrs(a'*))
  //   with
  //   	c   := <double-quote> cons; 
  //       a'* := [sdf-cons(c) , a*]
  //   
  // normalize: 
  // 	TemplateProductionWithCons(SortCons(s, Constructor(cons)), template, Attrs(a*)) ->
  //     TemplateProductionWithCons(SortCons(s, Constructor(cons)), template, Attrs(a'*))
  //    with
  //    	c   := <double-quote> cons; 
  //       a'* := [sdf-cons(c) , a*]
  
  
  	
  
  normalize:
  	SdfProduction(s, Rhs(symbols*), Attrs(a*)) ->
  		SdfProductionWithCons(SortCons(s, c), Rhs(symbols*), Attrs(a'*))
  	where
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?lift-constr)> a* 
  		
  
  //regular sdf2 productions become sdf3 productions with or without constructors     	
  normalize:
  	Prod(symbols*, Sort(s), Attrs(a*)) -> result
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?lift-constr)> a* ;
  		result := SdfProductionWithCons(SortCons(SortDef(s), c), Rhs(symbols*), Attrs(a'*))
  	<+  result := SdfProduction(SortDef(s), Rhs(symbols*), Attrs(a*)) 
  
  
  //Lexical kernel sdf2 productions become sdf3 productions with or without constructors     	
  normalize:
  	Prod(symbols*, Lex(Sort(s)), Attrs(a*)) -> result
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?lift-constr)> a* ;
  		result := SdfProductionWithCons(SortCons(Lex(SortDef(s)), c), Rhs(symbols*), Attrs(a'*))
  	<+  result := SdfProduction(Lex(SortDef(s)), Rhs(symbols*), Attrs(a*)) 
  
  //Cf kernel sdf2 productions become sdf3 productions with or without constructors     	
  normalize:
  	Prod(symbols*, Cf(Sort(s)), Attrs(a*)) -> result
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?lift-constr)> a* ;
  		result := SdfProductionWithCons(SortCons(Cf(SortDef(s)), c), Rhs(symbols*), Attrs(a'*))
  	<+  result := SdfProduction(Cf(SortDef(s)), Rhs(symbols*), Attrs(a*)) 
  
  
  //normalize reductive productions section to productive productions section
  normalize:
  	Contextfree(p*) -> ContextFreeSyntax(p*)
  	
  normalize:
  	Lexical(p*) -> LexicalSyntax(p*)
  	
  normalize:
  	Syntax(p*) -> Kernel(p*)	
  	  	
  /*normalize:
  	TemplateSection(t) -> [TemplateSection(t), contentcompletion*]
  	with
  		p* := < map(?TemplateProduction(<id>, _, _) <+ ?TemplateProductionWithCons(SortCons(<id>, Constructor(_)), _, _))
             ; nub 
             ; map(sort-to-contentcomplete)> t;	
        if [] := p*
        then
        	contentcompletion* := []
        else
          contentcompletion* := [SDFSection(ContextFreeSyntax(p*))]
        end
  
  
  normalize:
  	Module(m, i, sections) -> Module(m, i, sections')
  	with
  		sections' := <flatten-list> sections
*/  
        
  /*sort-to-contentcomplete:
     sort@Sort(s) -> SdfProductionWithCons(SortCons(sort, Constructor($[COMPLETION-[s]])), [Sort("CONTENTCOMPLETE")], Attrs([sdf-cons(c)]))
     with
     	c := <double-quote> $[COMPLETION-[s]]
   */  	
     	
  //normalize:
  	//SimpleRefGroup(SortCons(sort, Constructor(c))) -> <id> //SimpleGroup(prod')
  //	with
 // 		prod' := <get-def> c
 // 		; debug(!"a")
  	
  lift-constr:
  	Constructor(c) -> Constructor(<unquote>  c)
  	
  lift-constr:
    QuotedConstructor(c) -> Constructor(<unquote> c)
     
  		
  		
module analysis/types

imports 
  include/TemplateLang
  libstrc
  runtime/types/collect

imports
  
  lib/runtime/nabl/-
  lib/runtime/task/-
  lib/runtime/types/-
  lib/runtime/properties/-
  lib/runtime/relations/-
  analysis/name-constraints

  
signature
  constructors
  	
  	Inj : Constructor

overlays
  
  SortType(t)    = ConstType(SortNoArgs(t))
  OptionType(t)  = ConstType(Sort("Option", [SortNoArgs(t)]))
  ListType(t)    = ConstType(Sort("List", [SortNoArgs(t)]))
 


rules
  
  create-type-task(|ctx) =
    ?SingleLineTemplate(<filter(?Placeholder(_, _, _, _)); map(type-of)>)//; debug(!"singleline")
  ; type-is(|ctx)
    
  create-type-task(|ctx) =
    ?Template(<mapconcat(?Line(<filter(?Placeholder(_, _, _, _)); map(type-of)>))>)//; debug(!"multiline")
  ; type-is(|ctx)
    
  type-of:
    Placeholder(_, Sort(t), None(), _) -> SortType(t)

  type-of:
    Placeholder(_, Sort(t), Option(), _) -> OptionType(t)

  type-of:
    Placeholder(_, Sort(t), Plus(), _) -> ListType(t) 

  type-of:
    Placeholder(_, Sort(t), Star(), _) -> ListType(t) 
    
rules
  
  create-type-task(|ctx) =
  	?Rhs(<filter(create-type-task(|ctx) <+ not(is-lexical-symbol); debug(!"untypable ") ; fail)>)
  ; type-is(|ctx)	
    
  
  create-type-task(|ctx) :
    Sort(s) -> <task-create-id(|ctx,[t])> t
    where 
      t' := <type-lookup(|ctx)> s;
      t  := <task-create-make-set(|ctx)> t'
  
  create-type-task(|ctx) :
    Lex(Sort(s)) -> <task-create-id(|ctx,[t])> t
    where 
      t' := <type-lookup(|ctx)> s;
      t  := <task-create-make-set(|ctx)> t'
  
  create-type-task(|ctx) :
    Cf(Sort(s)) -> <task-create-id(|ctx,[t])> t
    where 
      t' := <type-lookup(|ctx)> s;
      t  := <task-create-make-set(|ctx)> t'
  	
  /*type-of:
    Sort(t) -> SortType(t)
    
  type-of(|ctx):
  	Lex(Sort(t)) -> <type-lookup(|ctx)> t
  
  type-of(|ctx):
  	Cf(Sort(t)) -> <type-lookup(|ctx)> t
  
  type-of(|ctx):
    Opt(s) -> <type-lookup(|ctx)> s
  
  type-of(|ctx):
    Iter(s) -> <type-lookup(|ctx)> s
  
  type-of(|ctx):
    IterStar(s) -> <type-lookup(|ctx)> s
  
  type-of(|ctx):
    IterSep(s, Lit(_)) -> ListType(<type-of> s)
  
  type-of(|ctx):
    IterStarSep(s, Lit(_)) -> ListType(<type-of> s)
   */ 
rules
	
	is-lexical-symbol = collect-one(?Lit(_) + ?CiLit(_) + ?CharClass(_)) 
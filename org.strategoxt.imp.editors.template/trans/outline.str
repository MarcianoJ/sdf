module outline

/*
 * When making changes to this code, do realise that it is used by both the SDF2 and SDF3 editors.
 */

imports
  include/TemplateLang
  lib/editor-common.generated
  lib/outline-library.generated

rules
  
  outline-strategy = alltd(outline-desugar); custom-label-outline(to-outline-label, to-outline-node)
  outline-expand-to-level = !2
  
rules
  
  outline-desugar = ?label(_, <id>)
  outline-desugar = ?unparameterized(<id>)
  outline-desugar = ?parameterized(<id>, _)
  
rules
  
  to-outline-icon(|name) = !["icons/", name, ".png"]; concat-strings
  
  icon-module = to-outline-icon(|"module")
  icon-exports = to-outline-icon(|"exports")
  icon-start = to-outline-icon(|"start")
  icon-prod-lex = to-outline-icon(|"prod-lex")
  icon-prod-cf = to-outline-icon(|"prod-cf")
  icon-layout = to-outline-icon(|"layout")
  icon-follow-restriction = to-outline-icon(|"follow-restriction")
  
  icon-cons-overlay = ?path; get-extension; ?extension; !(<remove-extension> path, "-cons"); conc-strings; !(<id>, extension); add-extension
  
rules
	
  // module
  to-outline-label:
    'module(name, _, _) -> name {<icon-module>}
  
  // start symbols
  to-outline-node:
    section -> Node(label{icon}, children)
    where
      <?kernel-start-symbols(symbols) + ?lexical-start-symbols(symbols) + ?context-free-start-symbols(symbols)> section;
      label := <section-to-outline-label> section;
      icon := <icon-exports>;
      children := <map(start-symbol-to-outline-label)> symbols

  start-symbol-to-outline-label:
    sort(symbol) -> Node(symbol {<icon-start>}, [])

  // lexical and context-free productions  
  to-outline-node:
    section -> Node(label{icon}, children)
    where
    	<?context-free-syntax(prods) + ?lexical-syntax(prods) + ?syntax(prods) + ?TemplateSection(prods)> section;
      label := <section-to-outline-label> section;
      icon := <icon-exports>
    where
    	if <?context-free-syntax(_) + ?TemplateSection(_)> := section
      then rules ( icon-prod := <icon-prod-cf>)
      else rules ( icon-prod := <icon-prod-lex>)
      end;
      'sorts := <reverse; collect-om(fetch-sort); reverse> prods; // why reverse? => collect-om returns the last element in case of duplicates; we want the first, for its origin
      children := <map(sort-to-outline-node(|prods))> 'sorts
 
  sort-to-outline-node(|prods):
    sort -> Node(label{icon}, children)
    where
      prods' := <collect-om(prod-has-sort(|sort), conc)> prods;
      Node(label{icon}, _) := <Hd; prod-to-outline-node> prods';
      if 1 := <length> prods'
      then children := []
      else children := <Tl; map(prod-to-outline-node)> prods'
      end
  
  prod-to-outline-node:
  	prod -> Node(label'{icon}, [])
  	where
      sort := <fetch-sort> prod;
      if layout() := sort
      then
        label := <origin-text> sort;
        icon := <icon-layout>
  		else if cons-name := <prod-to-cons> prod
  		then
  			label := <concat-strings> [<origin-text> sort, ".", cons-name];
  			icon := <icon-prod; icon-cons-overlay>
  	  else
  	  	label := <origin-text> sort;
  	  	icon := <icon-prod>
  	  end end;
  	  label' := <origin-set-relation> (sort, label)
  
  prod-to-cons: prod(_, _, attrs) -> <fetch-cons-name> attrs
  prod-to-cons: SdfProduction(_, _, attrs) -> <fetch-cons-name> attrs
  prod-to-cons = ?TemplateProductionWithCons(SortCons(_, <id>), _, _)
  
  fetch-sort = ?prod(_, <id>, _)
  fetch-sort = ?SdfProduction(<id>, _, _)
  fetch-sort = ?TemplateProductionWithCons(SortCons(<id>, _), _, _)
  fetch-sort = ?TemplateProduction(<id>, _, _)
  
  prod-has-sort(|sort) = ?prod; fetch-sort; ?sort; !prod

  // other sections
  to-outline-label:
    appl -> label {<icon-exports>}
    where
      <?variables(_) +
      ?lexical-variables(_) +
      ?lexical-priorities(_) +
      ?context-free-priorities(_) +
      
      ?aliases(_) + 
      ?restrictions(_)> appl;
      label := <section-to-outline-label> appl 

  // restrictions
    to-outline-node:
    section -> Node(label{icon}, children)
    where
      <?lexical-restrictions(restrictions) + ?context-free-restrictions(restrictions)> section;
      label := <section-to-outline-label> section;
      icon := <icon-exports>;
      symbolss := <reverse; collect-om(fetch-symbols); reverse> restrictions; // why reverse? => collect-om returns the last element in case of duplicates; we want the first, for its origin
      children := <map(restriction-symbols-to-outline-node(|restrictions))> symbolss

  restriction-symbols-to-outline-node(|restrictions):
    symbols -> Node(label'{icon}, children)
    where
      restrictions' := <collect-om(restriction-has-symbols(|symbols), conc)> restrictions;
      Node(label'{icon}, []) := <Hd; restriction-to-outline-node> restrictions';
      if 1 := <length> restrictions'
      then children := []
      else children := <Tl; map(restriction-to-outline-node)> restrictions'
      end

  restriction-to-outline-node:
    follow(symbols, _) -> Node(label'{icon}, [])
    where
      label := <origin-text> symbols;
      label' := <origin-set-relation> (symbols, label);
      icon := <icon-follow-restriction>

  fetch-symbols = ?follow(<id>, _)
  
  restriction-has-symbols(|symbols) = ?follow(symbols, _)

  // TODO: template options
  to-outline-label:
  	TemplateOptions(_) -> "template options" {<icon-exports>}

rules // utils

  section-to-outline-label:
    section -> label
    where
      label := <
        get-constructor;
        string-replace(|"context-free-", "context-free ");
        string-replace(|"lexical-", "lexical ");
        string-replace(|"TemplateOptions", "template options");
        string-replace(|"TemplateSection", "templates")
      > section  
  
  // should be a primitive?
  origin-set-relation:
  (origin-node, new-node) -> origin-tracked-node
  where
    origin-tracked-node := <!Some(<id>); all(!new-node); ?Some(<id>)> origin-node

signature constructors
  
  'module : ModuleName * List(ImpSection) * Sections -> Module
  True: Bool
  False: Bool
  
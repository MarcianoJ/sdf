module outline

imports
  include/TemplateLang
  lib/editor-common.generated
  lib/outline-library.generated

rules
  
  outline-strategy = alltd(label-desugar); custom-label-outline(to-outline-label, to-outline-node)
  outline-expand-to-level = !3
  label-desugar = ?label(_, <id>)
  
rules
  
  to-outline-icon(|name) = !["icons/", name, ".png"]; concat-strings
  
  icon-module = to-outline-icon(|"module")
  icon-exports = to-outline-icon(|"exports")
  icon-start = to-outline-icon(|"start")
  icon-prod-lex = to-outline-icon(|"prod-lex")
  icon-prod-cf = to-outline-icon(|"prod-cf")
  icon-prod-cf-cons = to-outline-icon(|"prod-cf-cons")
  icon-layout = to-outline-icon(|"layout")
  icon-multiple-prods = !["icons/", "multiple-prods", ".gif"]; concat-strings
  
rules
  
  to-outline-label:
    'module(moduleName, _, _) -> label {<icon-module>}
    where
      <?unparameterized(label) + ?parameterized(label, _)> := moduleName

  to-outline-label:
    appl -> label {<icon-exports>}
    where
      <?variables(_) +
      ?lexical-variables(_) +
      ?lexical-priorities(_) +
      ?context-free-priorities(_) +
      ?lexical-restrictions(_) +
      ?context-free-restrictions(_) + 
      ?aliases(_) + 
      ?restrictions(_) +
      start-symbols> appl;
      label := <appl-to-outline-label> appl
  
  to-outline-node:
    syntax-section -> Node(label{icon}, children)
    where
    	<?context-free-syntax(prods) + ?lexical-syntax(prods) + ?syntax(_)> syntax-section
    where
      label := <appl-to-outline-label> syntax-section;
      icon := <icon-exports>;
      'sorts := <reverse; collect-om(fetch-sort); reverse> prods; // reverse: collect-om returns the last element in case of duplicates; we want the first, for its origin
      children := <map(sort-to-outline-node(|prods))> 'sorts
 
  sort-to-outline-node(|prods):
    sort -> Node(label{icon}, children)
    where
      prods' := <collect-om(prod-has-sort(|sort), conc)> prods;
      
      if 1 := <length> prods'
      then
        if cons-name := <Hd; prod-to-cons> prods'
        then
          label := <concat-strings> [<origin-text> sort, ".", cons-name];
          icon := <icon-prod-cf-cons>
        else
          label := <origin-text> sort;
          icon := <icon-prod-cf>
        end;
        children := []
        
      else
        label := <origin-text> sort;
        icon := <icon-multiple-prods>;
        children := <map(prod-to-outline-node(|prods))> prods'
      end
  
  fetch-sort = ?prod(_, sort, _); !sort
  
  prod-to-outline-node(|prods):
  	prod -> Node(label{icon}, [])
  	where
      sort := <fetch-sort> prod;
  		if cons-name := <prod-to-cons> prod
  		then
  			label := <concat-strings> [<origin-text> sort, ".", cons-name];
  			icon := <icon-prod-cf-cons>
  	  else
  	  	label := <origin-text> sort;
  	  	icon := <icon-prod-cf>
  	  end
  
  
  prod-to-cons:
    prod(_, _, attrs) -> <fetch-cons-name> attrs
  
  prod-has-sort(|sort) = ?prod; fetch-sort; ?sort; !prod
  
  to-outline-label(|parent):
    sort(startSymbol) -> startSymbol {<icon-start>}
    where
      <start-symbols> parent
 
rules

  start-symbols = 
    ?kernel-start-symbols(_) + 
    ?lexical-start-symbols(_) + 
    ?context-free-start-symbols(_)
  
  appl-to-outline-label:
    appl -> label
    where
      label := <
        get-constructor; 
        string-replace(|"context-free-", "context-free "); 
        string-replace(|"lexical-", "lexical ")
      > appl  

signature constructors
  
  'module : ModuleName * List(ImpSection) * Sections -> Module
  
module to-sdf
imports
  libstratego-lib
  libstratego-sglr
  include/TemplateLang
  templatelang/analyze
  templatelang/desugar
  templatelang/utils/attributes
  templatelang/utils/contract
  templatelang/utils/misc
  templatelang/utils/tokenize



rules
 
 to-sdf-test(|mn, i*) = 
 	module-to-sdf
  
  module-to-sdf:
  	Module(Unparameterized(mn), i, sections) ->
  		'module(unparameterized(mn), imports, exports)
  	with
  		if [] := sections
  		then
  			exports := []
  		else
  		    exports := exports(<map(section-to-sdf)> sections)
  		end;
  		imports := <map(imports-to-sdf)> i
  		
  module-to-sdf:
  	Module(Unparameterized(mn)) -> 'module(unparameterized(mn))
  	
  module-to-sdf:
  	Module(Parameterized(mn, symbols)) -> 'module(parameterized(mn, symbols'))
  	with
  		symbols' := <term-translation> symbols
  		
  
   imports-to-sdf: 
  	Imports(mod) -> imports(i)
  	with
  		i := <map(module-to-sdf)> mod
  		
  
  
  /* SDF3 sections */
  //Context-free Start Symbols
  section-to-sdf: 
  	SDFSection(ContextFreeStartSymbols(symbols)) -> context-free-start-symbols(symbols')
  	with
  		symbols' := <term-translation> symbols
  		
  //KernelStartSymbols -> kernel-start-symbols
  section-to-sdf: 
  	SDFSection(KernelStartSymbols(symbols)) -> kernel-start-symbols(symbols')
  	with
  		symbols' := <term-translation> symbols
  
  //LexicalStartSymbols -> lexical-start-symbols
  section-to-sdf: 
  	SDFSection(LexicalStartSymbols(symbols)) -> lexical-start-symbols(symbols')
  	with
  		symbols' := <term-translation> symbols
  		
  //productive productions section
  section-to-sdf:
  	SDFSection(ContextFreeSyntax(prods)) -> context-free-syntax(prods')
  	with
  		prods' := <term-translation> prods
  
  //reductive productions section
  section-to-sdf:
  	SDFSection(Contextfree(prods)) -> context-free-syntax(prods')
  	with
  		prods' := <term-translation> prods
  		
  //lexical syntax productive section
  section-to-sdf:
  	SDFSection(LexicalSyntax(prods)) -> lexical-syntax(prods')
  	with
  		prods' := <term-translation> prods
  
   //lexical syntax reductive section
  section-to-sdf:
  	SDFSection(Lexical(prods)) -> lexical-syntax(prods')
  	with
  		prods' := <term-translation> prods
  		
  //kernel syntax
  section-to-sdf:
  	SDFSection(Syntax(prods)) -> syntax(prods')
  	with
  		prods' := <term-translation> prods
  		
  //lexical restrictions
  section-to-sdf:
  	SDFSection(LexicalRestrictions(restrictions)) -> lexical-restrictions(restrictions')
  	with
  		restrictions' := <term-translation> restrictions
  		
  //context-free restrictions
   section-to-sdf:
  	SDFSection(ContextFreeRestrictions(restrictions)) -> context-free-restrictions(restrictions')
  	with
  		restrictions' := <term-translation> restrictions
  
  
  //kernel restrictions
  section-to-sdf:
  SDFSection(Restrictions(restrictions)) -> restrictions(restrictions')
  	with
  		restrictions' := <term-translation> restrictions
  		
  //sorts 
  section-to-sdf:
  SDFSection(Sorts(symbols)) -> 'sorts(symbols')
  	with
  		symbols' := <term-translation> symbols
  
  //aliases
  section-to-sdf:
  SDFSection(Aliases(aliases)) -> aliases(aliases')
  	with
  		aliases' := <term-translation> aliases
  
  //variables
  section-to-sdf:
  	SDFSection(Variables(prods)) -> variables(prods')
  	with
  		prods' := <term-translation> prods
  
    //lexical variables
   section-to-sdf:
  	SDFSection(LexVariables(prods)) -> lexical-variables(prods')
  	with
  		prods' := <term-translation> prods
  
  
  //context-free priorities
  section-to-sdf:
  	SDFSection(ContextFreePriorities(priorities)) -> context-free-priorities(priorities')
  	with
  		priorities' := <map(priority-to-sdf)> priorities
  
  //lexical priorities
  section-to-sdf:
  	SDFSection(LexicalPriorities(priorities)) -> lexical-priorities(priorities')
  	with
  		priorities' := <map(priority-to-sdf)> priorities
  
  //kernel priorities
  section-to-sdf:
  	SDFSection(Priorities(priorities)) -> priorities(priorities')
  	with
  		priorities' := <map(priority-to-sdf)> priorities
  
  priority-to-sdf:
  	Chain(groups) -> chain(groups')
  	with
  		groups' := <map(sdf3-group-to-sdf <+ term-translation)> groups
  
  
  priority-to-sdf:
  	Assoc(gr1, associativity, gr2) -> assoc(gr1', associativity', gr2')
  	with
  		gr1' := <sdf3-group-to-sdf <+ term-translation> gr1;
  		associativity' := <term-translation> associativity;
  		gr2' := <sdf3-group-to-sdf <+ term-translation> gr2
  
  sdf3-group-to-sdf:
    SimpleRefGroup(ref) -> []//simple-group(ref)
  
  sdf3-group-to-sdf:
    ProdsRefGroup(ref) -> []//prods-group(ref)
    
  sdf3-group-to-sdf:
    AssocRefGroup(a, ref) -> []//assoc-group(a, ref)
  
  special-term-to-sdf:
    SimpleRefGroup(ref) -> []//simple-group(ref)
  
  special-term-to-sdf:
    ProdsRefGroup(ref) -> []//simple-group(ref)
    
  special-term-to-sdf:
    AssocRefGroup(a, ref) -> []//simple-group(ref)  
  
  
  
  
  
  
    
  //TemplateOptions
  section-to-sdf:
  	TemplateOptions(args) -> []
  
  //TemplateSection
  section-to-sdf:
  	TemplateSection(x) -> [context-free-syntax(p*), inj*, restr*]
  	with
  		p* := <map(tproduction-to-sdf)> x;
  		//content complete prods
  		inj* := [];
  		// lexical restrictions
  		restr* := []
  
  tproduction-to-sdf:
  	Desugared(TemplateProduction(s, t, a)) -> prod(t', s', a')
  	with
  		t' := <ttemplate-to-sdf> t;
  		s' := <term-translation> s;
  		a' := <term-translation> a		
  
  //single-line template
  ttemplate-to-sdf:
  	SingleLineTemplate(elems) -> elems'
  	with
  	elems' := <filter(template-elem-to-sdf)> elems
  	
  template-elem-to-sdf:
  	String(t) -> <string-to-sdf> t
  	
  template-elem-to-sdf:
  	Placeholder(None(), Sort(x), regular, option) -> result
  	where <not(one(Separator(not(string-is-layout))))> option
  	with
  		switch !(regular)
  		case ?(Star()) : result := iter-star(sort(x))
  		case ?(Option()) : result := opt(sort(x))
  		case ?(Plus()) : result := iter(sort(x))
  		case ?(None()) : result := sort(x)
  		end
  		
  template-elem-to-sdf:
  	Placeholder(None(), Sort(x), regular, option) -> result
  	where <one(Separator(not(string-is-layout)))> option
  	with
  		switch !(regular)
  		case ?(Star()) : result := iter-star-sep(sort(x), lit(<separator-to-literal> option))
  		case ?(Plus()) : result := iter-sep(sort(x), lit(<separator-to-literal> option))
  		end
  	
  	
  template-elem-to-sdf:
  	Placeholder(Label(Unquoted(l)), Sort(x), regular, option) -> label(unquoted(l), result)	
  	where <not(one(Separator(not(string-is-layout))))> option
  	with
  		switch !(regular)
  		case ?(Star()) : result := iter-star(sort(x))
  		case ?(Option()) : result := opt(sort(x))
  		case ?(Plus()) : result := iter(sort(x))
  		case ?(None()) : result := sort(x)  		
  		end
  
  template-elem-to-sdf:
  	Placeholder(Label(Unquoted(l)), Sort(x), regular, option) -> label(unquoted(l), result)	
  	where <one(Separator(not(string-is-layout)))> option
  	with
  		switch !(regular)
  		case ?(Star()) : result := iter-star-sep(sort(x), lit(<separator-to-literal> option))
  		case ?(Plus()) : result := iter-sep(sort(x), lit(<separator-to-literal> option)) 		
  		end
  
  //multi-line template
  ttemplate-to-sdf:
     Template(lines) -> elems
     with
     	elems := <filter(?Line([Layout(_), _ | _])); map(line-to-sdf)> lines
 
  line-to-sdf:
  	Line(elems) -> elems'
  	with
  		elems' := <filter(template-elem-to-sdf)> elems
  


rules //conversion of SDF3 terms into SDF2
	
  term-translation = topdown(try(terms-to-sdf <+ special-term-to-sdf <+ term-to-sdf ))
	
	//regular constructor conversion
  term-to-sdf:
  	cons#(args) -> cons'#(args)
  	with
  		[f|fs] := <explode-string> cons;
  		cons' := <implode-string> [<to-lower> f|fs]
  
  //special constructors conversion		
  special-term-to-sdf:
  	IterSep(sort, lit) -> iter-sep(sort, lit)
  
  special-term-to-sdf:
  	IterStar(sort) -> iter-star(sort)
  		
  special-term-to-sdf:
  	Simple(sort) -> simple-charclass(sort)
  	
  special-term-to-sdf:
  	CharClass(sort) -> char-class(sort)
  	
  special-term-to-sdf:
  	QuotedConstructor(sort) -> Constructor(sort)
  	
  special-term-to-sdf:
  	LabelStart() -> label_start()
  	
  special-term-to-sdf:
  	Empty() -> empty-grammar()
  
  special-term-to-sdf:
  	UnquotedFun(s) -> unquoted-fun(s)
  
  special-term-to-sdf:
  	QuotedFun(s) -> quoted-fun(s)
  
  special-term-to-sdf:
  	PrefixFun(fn, syms, sym, att) -> prefix-fun(fn, syms, sym, att)	
  
  special-term-to-sdf:
  	NonAssoc() -> non-assoc()
  	
  special-term-to-sdf:
  	NoAttrs() -> no-attrs()
  	
  special-term-to-sdf:
  	WithArguments(g, a) -> with-arguments(g, a)
  
  special-term-to-sdf:
  	NonTransitive(g) -> non-transitive(g)
  
  special-term-to-sdf:
  	SimpleGroup(p) -> simple-group(p)
  		
  special-term-to-sdf:
  	ProdsGroup(p) -> prods-group(p)	
        
  special-term-to-sdf:
  	AssocGroup(a, p) -> assoc-group(a, p)
  
  special-term-to-sdf:
  	RealCon(i, n, o) -> real-con(i, n, o)	
  
  special-term-to-sdf:
  	IterStarSep(sort, sep) -> iter-star-sep(sort, sep)	
  
  special-term-to-sdf:
  	FileStart() -> file-start()
  	
  special-term-to-sdf:
  	ParameterizedSort(sort, sym) -> parameterized-sort(sort, sym)	
  		     
  special-term-to-sdf:
  	CiLit(lit) -> ci-lit(lit)
  		  		
  terms-to-sdf:
  	[term | tail] -> <id>
  		
  terms-to-sdf:
  	[] -> []





rules



  /** @type List(TemplateSection | ...) -> List(grammar) */
  template-sections-to-sdf =
  	alltd(desugar-sdf-redux-tmpl);
    filter(template-section-to-sdf);
    concat

rules // lookup of template production, e.g. Exp.Plus

  //desugar-sdf-redux-tmpl:
  //  simple-ref-group(ref) -> simple-group(<SortCons-to-prod-tmpl> ref)
    
  desugar-sdf-redux-tmpl:
    SimpleRefGroup(ref) -> simple-group(<SortCons-to-prod-tmpl> ref)
  

  //desugar-sdf-redux-tmpl:
    //prods-ref-group(ref*) -> prods-group(<map(SortCons-to-prod-tmpl)> ref*)
  
  desugar-sdf-redux-tmpl:
    ProdsRefGroup(ref*) -> prods-group(<map(SortCons-to-prod-tmpl)> ref*)

  // desugar-sdf-redux-tmpl:
  //   assoc-ref-group(a, ref*) -> assoc-group(a, <map(SortCons-to-prod-tmpl)> ref*)
    
  desugar-sdf-redux-tmpl:
    AssocRefGroup(a, ref*) -> assoc-group(a, <map(SortCons-to-prod-tmpl)> ref*)

  SortCons-to-prod-tmpl:
    SortCons(sort, Constructor(cons)) -> t
    with <TemplateProductionDef; template-production-to-sdf-no-attrs> (sort, cons) => t 
		   
  create-template-production-dr :
  	(lhs, rhs) -> <rules( TemplateProductionDef : lhs -> rhs )>

rules

  /** @type TemplateSection -> grammar */
  template-section-to-sdf:
    TemplateSection(x) -> [context-free-syntax(p*), inj*, restr*]
    where with-spxverify(
      p* := <map(template-production-to-sdf)> x;

      // content complete productions
      p'* := <map(templatelang-prod-to-sort); nub;
              map(sort-to-contentcomplete)> x;
      if !p'* => [] then
        inj* := []
      else
        inj* := [context-free-syntax(p'*)]
      end;

      // lexical restrictions
      let chars-end-with-identifier-char =
            where(reverse; ?[<is-alphanum + '_'> | _])

          string-ends-with-identifier-char =
            where(explode-string; chars-end-with-identifier-char)
      in
        r* := <collect-om(?String(<string-ends-with-identifier-char>));
               filter(string-to-sdf; last)> x;
        r  := <templatelang-get-option <+ debug(!"Failed: "); fail> KeywordFollowRestriction();
        if !r* => [] + !r => None() then
          restr* := []
        else
          restr* := [lexical-restrictions([follow(r*, r)])]
        end
      end
      , !"Failed to convert TemplateSection to SDF"
    )

  template-section-to-sdf:
    SDFSection(x) -> [x]

rules

  // Used when rewriting `Sort.Cons' in priority sections to a production.
  template-production-to-sdf-no-attrs:
    Desugared(TemplateProduction(S', t, _)) -> p|[ A* -> S' ]|
    where with-spxverify (
      A* := <template-to-sdf> t
    )

  template-production-to-sdf-no-attrs =
    templatelang-not-desugared(|"generate SDF (no attrs) from")

  template-production-to-sdf:
    Desugared(TemplateProduction(S', t, attrs)) -> p|[ A* -> S' attrs' ]|
    where with-spxverify (
      A* := <template-to-sdf> t;
      attrs' := <attrs(filter(not(?sdf-completion(_)))) <+ no-attrs()> attrs
    )

  template-production-to-sdf =
    templatelang-not-desugared(|"generate SDF from")

  // Single line template.
  //  -OR-
  // Template with only a placeholder. (i.e., injection)
  // The placeholder is at the start AND at the end of the template!
  template-to-sdf:
    < ?SingleLineTemplate(elem*)
    + ?Template([Line(elem* @ [Layout(_), Placeholder(label, _, _, _)])]) > -> A*
    where with-spxverify (
      A* := <maybe-separating(
               filter(template-element-to-sdf-sep <+ template-element-to-sdf),
               filter(template-element-to-sdf)
             );
             flatten-list> elem*
    )

  // Multi line template.
  template-to-sdf:
    Template(line*) -> A*
    where with-spxverify (
      A* := <filter(?Line([Layout(_), _ | _]));
             maybe-separating(
                !(<id>, 0); thread-map(template-line-to-sdf-sep); ?(<id>, _),
                map(template-line-to-sdf)
             );
             flatten-list> line*
    )
  maybe-separating(yes, no) =
    if <templatelang-get-option> Newlines() => Separating() then yes else no end

rules

  template-line-to-sdf-sep:
    (Line([Layout(_), p @ Placeholder(label, sort(S), mult, option*)]), state) ->
      (result, state)
    where
      <one(Separator(is-substring(!"\n")))> option*
    where
      L := "\"\\n\"";
      switch !(mult, state)
        case ?(None()  , 0) : result := A|[ (S L)  ]|
        case ?(Option(), 0) : result := A|[ (S L)? ]|
        case ?(Star()  , 0) : result := A|[ (S L)* ]|
        case ?(Plus()  , 0) : result := A|[ (S L)+ ]|
        case ?(None()  , 1) : result := A|[ (L S)  ]|
        case ?(Option(), 1) : result := A|[ (L S)? ]|
        case ?(Star()  , 1) : result := A|[ (L S)* ]|
        case ?(Plus()  , 1) : result := A|[ (L S)+ ]|
      end

  template-line-to-sdf-sep:
    (Line(elem*), 0) -> (<template-line-to-sdf-sep-helper> elem*, 1)

  template-line-to-sdf-sep:
    (Line(elem*), 1) ->
      ([ A|[ "\"\\n\"" ]| | <template-line-to-sdf-sep-helper> elem*], 1)

  template-line-to-sdf-sep-helper =
    not(?[Layout(_), Placeholder(label, _, _, <one(Separator(is-substring(!"\n")))>)]);
    filter(template-element-to-sdf-sep <+ template-element-to-sdf)

  template-element-to-sdf-sep:
    Placeholder(label, sort(S), Star(), option*) -> A|[ {S "\"\\n\""}* ]|
    where <one(Separator(is-substring(!"\n")))> option*

  template-element-to-sdf-sep:
    Placeholder(label, sort(S), Plus(), option*) -> A|[ {S "\"\\n\""}+ ]|
    where <one(Separator(is-substring(!"\n")))> option*

rules

  template-line-to-sdf =
    ?Line(<id>);
    if not(?[Layout(_), Placeholder(label, _, _, _)]) then
      switch <templatelang-get-option> Newlines()
        case ?None()     : id
        case ?Leading()  : ![String("\n") | <id>]
        case ?Trailing() : (elem* -> [elem*, String("\n")])
      end
    end;
    filter(template-element-to-sdf)

  template-element-to-sdf:
    String(x) -> <string-to-sdf> x

  template-element-to-sdf:
    Placeholder(None(), sort(S), None(), _) -> A|[ S ]|

  template-element-to-sdf:
    Placeholder(Label(l), sort(s), None(), _) -> label(unquoted(l), sort(s))

  template-element-to-sdf:
    Placeholder(label, sort(S), Option(), _) -> A|[ S? ]|

  template-element-to-sdf:
    Placeholder(label, sort(S), Star(), option*) -> A|[ S* ]|
    where <not(one(Separator(not(string-is-layout))))> option*

  template-element-to-sdf:
    Placeholder(label, sort(S), Star(), option*) -> A|[ { S L }* ]|
    where <one(Separator(not(string-is-layout)))> option*
    where with-spxverify ( L := <separator-to-literal> option*)

  template-element-to-sdf:
    Placeholder(label, sort(S), Plus(), option*) -> A|[ S+ ]|
    where <not(one(Separator(not(string-is-layout))))> option*

  template-element-to-sdf:
    Placeholder(label, sort(S), Plus(), option*) -> A|[ { S L }+ ]|
    where <one(Separator(not(string-is-layout)))> option*
    where with-spxverify( L := <separator-to-literal> option*  )

  char-is-layout =
    ' ' + '\t' + '\r' + '\n'

  string-is-layout =
    string-as-chars(all(char-is-layout))

  remove-layout =
    string-as-chars(filter(not(char-is-layout)))

  separator-to-literal =
    getfirst(?Separator(<remove-layout; templatelang-escape; double-quote>))

  sort-to-contentcomplete:
    S -> p|[ CONTENTCOMPLETE -> S {cons(L)} ]|
    where
      L := $["COMPLETION-[S]"]

strategies

  /**
   * Sorts a list of terms on the outermost string within each term.
   */
  string-sort-ex =
    qsort(<string-lt> (<collect-one(is-string)>, <collect-one(is-string)>))

  /**
   * Split on the edges delimiting identifiers.
   * E.g. "func(x,y)" => ["func", "(", "x", ",", "y", ")"]
   */
  string-to-sdf =
    where( chars := <templatelang-get-option> Tokenize() );
    string-edge-tokenize(where({x: ?x; <one(?x)> chars}));
    // FIXME: Case insensitive literals need ci-lit/single-quote.
    map(!lit(<templatelang-escape; double-quote>))

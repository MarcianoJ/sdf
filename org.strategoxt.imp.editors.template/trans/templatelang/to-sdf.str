module to-sdf
imports
  libstratego-lib
  libstratego-sglr
  include/TemplateLang
  templatelang/analyze
  templatelang/desugar
  templatelang/utils/attributes
  templatelang/utils/contract
  templatelang/utils/misc
  templatelang/utils/tokenize

rules

  /** @type List(TemplateSection | ...) -> List(grammar) */
  template-sections-to-sdf =
    filter(template-section-to-sdf);
    concat

  /** @type TemplateSection -> grammar */
  template-section-to-sdf:
    TemplateSection(x) -> [context-free-syntax(p*), inj*, restr*]
    where with-spxverify(
      p* := <map(template-production-to-sdf)> x;

      // content complete productions
      p'* := <map(templatelang-prod-to-sort); nub;
              map(sort-to-contentcomplete)> x;
      if !p'* => [] then
        inj* := []
      else
        inj* := [context-free-syntax(p'*)]
      end;

      // lexical restrictions
      let chars-end-with-identifier-char =
            where(reverse; ?[<is-alphanum + '_'> | _])

          string-ends-with-identifier-char =
            where(explode-string; chars-end-with-identifier-char)
      in
        r* := <collect-om(?String(<string-ends-with-identifier-char>));
               filter(string-to-sdf; last)> x;
        r  := <templatelang-get-option <+ debug(!"Failed: "); fail> KeywordFollowRestriction();
        if !r* => [] + !r => None() then
          restr* := []
        else
          restr* := [lexical-restrictions([follow(r*, r)])]
        end
      end
      , !"Failed to convert TemplateSection to SDF"
    )

  template-section-to-sdf:
    SDFSection(x) -> [x]

rules

  // Used when rewriting `Sort.Cons' in priority sections to a production.
  template-production-to-sdf-no-attrs:
    Desugared(TemplateProduction(S', t, _)) -> p|[ A* -> S' ]|
    where with-spxverify (
      A* := <template-to-sdf> t
    )

  template-production-to-sdf-no-attrs =
    templatelang-not-desugared(|"generate SDF (no attrs) from")

  template-production-to-sdf:
    Desugared(TemplateProduction(S', t, attrs)) -> p|[ A* -> S' attrs' ]|
    where with-spxverify (
      A* := <template-to-sdf> t;
      attrs' := <attrs(filter(not(?sdf-completion(_)))) <+ no-attrs()> attrs
    )

  template-production-to-sdf =
    templatelang-not-desugared(|"generate SDF from")

  // Single line template.
  //  -OR-
  // Template with only a placeholder. (i.e., injection)
  // The placeholder is at the start AND at the end of the template!
  template-to-sdf:
    < ?SingleLineTemplate(elem*)
    + ?Template([Line(elem* @ [Layout(_), Placeholder(label, _, _, _)])]) > -> A*
    where with-spxverify (
      A* := <maybe-separating(
               filter(template-element-to-sdf-sep <+ template-element-to-sdf),
               filter(template-element-to-sdf)
             );
             flatten-list> elem*
    )

  // Multi line template.
  template-to-sdf:
    Template(line*) -> A*
    where with-spxverify (
      A* := <filter(?Line([Layout(_), _ | _]));
             maybe-separating(
                !(<id>, 0); thread-map(template-line-to-sdf-sep); ?(<id>, _),
                map(template-line-to-sdf)
             );
             flatten-list> line*
    )
  maybe-separating(yes, no) =
    if <templatelang-get-option> Newlines() => Separating() then yes else no end

rules

  template-line-to-sdf-sep:
    (Line([Layout(_), p @ Placeholder(label, sort(S), mult, option*)]), state) ->
      (result, state)
    where
      <one(Separator(is-substring(!"\n")))> option*
    where
      L := "\"\\n\"";
      switch !(mult, state)
        case ?(None()  , 0) : result := A|[ (S L)  ]|
        case ?(Option(), 0) : result := A|[ (S L)? ]|
        case ?(Star()  , 0) : result := A|[ (S L)* ]|
        case ?(Plus()  , 0) : result := A|[ (S L)+ ]|
        case ?(None()  , 1) : result := A|[ (L S)  ]|
        case ?(Option(), 1) : result := A|[ (L S)? ]|
        case ?(Star()  , 1) : result := A|[ (L S)* ]|
        case ?(Plus()  , 1) : result := A|[ (L S)+ ]|
      end

  template-line-to-sdf-sep:
    (Line(elem*), 0) -> (<template-line-to-sdf-sep-helper> elem*, 1)

  template-line-to-sdf-sep:
    (Line(elem*), 1) ->
      ([ A|[ "\"\\n\"" ]| | <template-line-to-sdf-sep-helper> elem*], 1)

  template-line-to-sdf-sep-helper =
    not(?[Layout(_), Placeholder(label, _, _, <one(Separator(is-substring(!"\n")))>)]);
    filter(template-element-to-sdf-sep <+ template-element-to-sdf)

  template-element-to-sdf-sep:
    Placeholder(label, sort(S), Star(), option*) -> A|[ {S "\"\\n\""}* ]|
    where <one(Separator(is-substring(!"\n")))> option*

  template-element-to-sdf-sep:
    Placeholder(label, sort(S), Plus(), option*) -> A|[ {S "\"\\n\""}+ ]|
    where <one(Separator(is-substring(!"\n")))> option*

rules

  template-line-to-sdf =
    ?Line(<id>);
    if not(?[Layout(_), Placeholder(label, _, _, _)]) then
      switch <templatelang-get-option> Newlines()
        case ?None()     : id
        case ?Leading()  : ![String("\n") | <id>]
        case ?Trailing() : (elem* -> [elem*, String("\n")])
      end
    end;
    filter(template-element-to-sdf)

  template-element-to-sdf:
    String(x) -> <string-to-sdf> x

  template-element-to-sdf:
    Placeholder(label, sort(S), None(), _) -> A|[ S ]|

  template-element-to-sdf:
    Placeholder(label, sort(S), Option(), _) -> A|[ S? ]|

  template-element-to-sdf:
    Placeholder(label, sort(S), Star(), option*) -> A|[ S* ]|
    where <not(one(Separator(not(string-is-layout))))> option*

  template-element-to-sdf:
    Placeholder(label, sort(S), Star(), option*) -> A|[ { S L }* ]|
    where <one(Separator(not(string-is-layout)))> option*
    where with-spxverify ( L := <separator-to-literal> option*)

  template-element-to-sdf:
    Placeholder(label, sort(S), Plus(), option*) -> A|[ S+ ]|
    where <not(one(Separator(not(string-is-layout))))> option*

  template-element-to-sdf:
    Placeholder(label, sort(S), Plus(), option*) -> A|[ { S L }+ ]|
    where <one(Separator(not(string-is-layout)))> option*
    where with-spxverify( L := <separator-to-literal> option*  )

  char-is-layout =
    ' ' + '\t' + '\r' + '\n'

  string-is-layout =
    string-as-chars(all(char-is-layout))

  remove-layout =
    string-as-chars(filter(not(char-is-layout)))

  separator-to-literal =
    getfirst(?Separator(<remove-layout; templatelang-escape; double-quote>))

  sort-to-contentcomplete:
    S -> p|[ CONTENTCOMPLETE -> S {cons(L)} ]|
    where
      L := $["COMPLETION-[S]"]

strategies

  /**
   * Sorts a list of terms on the outermost string within each term.
   */
  string-sort-ex =
    qsort(<string-lt> (<collect-one(is-string)>, <collect-one(is-string)>))

  /**
   * Split on the edges delimiting identifiers.
   * E.g. "func(x,y)" => ["func", "(", "x", ",", "y", ")"]
   */
  string-to-sdf =
    where( chars := <templatelang-get-option> Tokenize() );
    string-edge-tokenize(where({x: ?x; <one(?x)> chars}));
    // FIXME: Case insensitive literals need ci-lit/single-quote.
    map(!lit(<templatelang-escape; double-quote>))

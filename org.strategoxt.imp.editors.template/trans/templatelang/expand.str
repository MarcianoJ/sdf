module expand

imports
  include/TemplateLang
  templatelang/utils/attributes
  templatelang/utils/stubs
  templatelang/analyze
  templatelang/to-string

strategies

  // Many of the following strategies fail if a placeholder is encountered
  // that has been expanded before (i.e., a cycle).

  // The failure propagates up and is handled by the filter strategy in
  // get-template-lines / get-template-elements, so that placeholders that
  // would lead to infinite recursion are never expanded.

  /**
   * @type TemplateProduction ->? List(template-line)
   */
  expand-multi-line-template-production:
    TemplateProduction(sort, SingleLineTemplate(elem*), a) ->
      <memo(expand-template-production)> TemplateProduction(sort, Template([Line(elem*)]), a)

  expand-multi-line-template-production:
    TemplateProduction(_, Template(_), _) -> <memo(expand-template-production)>

  /**
   * @type TemplateProduction ->? List(template-element)
   */
  expand-single-line-template-production:
    TemplateProduction(_, SingleLineTemplate(_), _) -> <memo(expand-template-production)>

  /**
   * @type TemplateProduction ->? List(template-line) | List(template-element)
   */
  expand-template-production:
    TemplateProduction(sort, template, attrs) -> result{score}
    where
      <not(is-reject)> attrs
    where
      result := <expand-template> template;
      score := <determine-score> attrs

  /**
   * @type template-attributes -> Int
   */
  determine-score:
    attrs -> <sum> [depr', prefer', avoid']
    where
      depr'   := <is-deprecated < !-100 + !0> attrs;
      prefer' := <is-completion-prefer < !50 + !0> attrs;
      avoid'  := <is-completion-avoid < !-50 + !0> attrs

  /**
   * @type SingleLineTemplate ->? List(template-element)
   */
  expand-template:
    t @ SingleLineTemplate(elem*) -> elem'*
    where
      elem'* := <listbu(expand-template-element)> elem*

  /**
   * @type Template ->? List(template-line)
   */
  expand-template:
    t @ Template(line*) -> line'*
    where
      line'* := <listbu(expand-template-line)> line*

  /**
   * @type List(template-line) ->? List(template-line)
   *
   * expand-template-line covers exactly all valid input terms except:
   *  Line([indent @ Layout(_), Placeholder(sort(x), <None() + Plus()>, _)]) where <Expanded> x
   */
  expand-template-line:
    [t @ Line([indent @ Layout(_), Placeholder(label, sort(x), m @ <None() + Plus()>, option*)]) | tail] -> [line'* | tail]
    where
      <not(Expanded)> x;
      <not(one(?Hide() + ?Text(_)))> option*
    where
      line* := <get-template-lines(|indent) <+ ![t]> x;
      if ?[Line([indent, p @ Placeholder(_, _, _, _)])] then
        text := <template-element-to-string> p;
        line'* := [Line([indent, Placeholder(label, sort(x), m, [Text(text) | option*])])]
      else
        line'* := line*
      end

  // Do not touch already expanded placeholders.
  expand-template-line:
    [t @ Line([Layout(_), Placeholder(label, sort(x), <None() + Plus()>, option*)]) | tail] -> [t | tail]
    where
      <Expanded> x
      + <one(?Text(_))> option*

  // Do not touch option/star placeholders.
  expand-template-line:
    [t @ Line([Layout(_), Placeholder(label, _, <Option() + Star()>, option*)]) | tail] -> [t | tail]
    where
      <not(one(?Hide()))> option*

  // Remove line with hidden placeholder.
  expand-template-line:
    [Line([Layout(_), Placeholder(label, _, _, option*)]) | tail] -> tail
    where
      <one(?Hide())> option*

  expand-template-line:
    [t @ Line(elem*) | tail] -> t'
    where
      not(!elem* => [Layout(_), Placeholder(label, _, <None() + Plus()>, _)])
    where
      t' := <![Line(<listbu(expand-template-element); not(?[])>) | tail] <+ !tail> elem*

  expand-template-line:
    [] -> <id>

  /**
   * @type List(template-element) ->? List(template-element)
   *
   * expand-template-element covers exactly all valid input terms except:
   *  Placeholder(sort(x), <None() + Plus()>, _) where <Expanded> x
   */
  expand-template-element:
    [t @ Placeholder(label, sort(x), m @ <None() + Plus()>, option*) | tail] ->
      // [elem* | tail]
      [Placeholder(label, sort(x), m, [Text(text) | option*]) | tail]
    where
      <not(Expanded)> x;
      <not(one(?Hide() + ?Text(_)))> option*
    where
      elem* := <get-template-elements <+ ![t]> x;
      text := <map(template-element-to-string); concat-strings> elem*

  // Do not touch already expanded placeholders.
  expand-template-element:
    [t @ Placeholder(label, sort(x), <None() + Plus()>, option*) | tail] -> [t | tail]
    where
      <Expanded> x
      + <one(?Text(_))> option*

  // Do not touch option/star placeholders.
  expand-template-element:
    [t @ Placeholder(label, _, <Option() + Star()>, option*) | tail] -> [t | tail]
    where
      <not(one(?Hide()))> option*

  // Remove hidden placeholder.
  expand-template-element:
    [Placeholder(label, _, _, option*) | tail] -> tail
    where
      <one(?Hide())> option*

  expand-template-element:
    [t | tail] -> [t | tail]
    where
      not(!t => Placeholder(label, sort(x), <None() + Plus()>, _))

  expand-template-element:
    [] -> <id>

strategies  // helpers

  get-templates =
    ?sort;
    rules( Expanded : sort -> sort );
    <resolve-all-symbol-definitions> (sort, TemplateBySort());
    not(?[])

  /**
   * @type String -> List(template-line)
   */
  get-template-lines(|indent) =
    {|Expanded:
      get-templates;
      filter(expand-multi-line-template-production);
      choose-one-expansion;
      map(Line(![indent | <id>]))
    |}

  /**
   * @type String -> List(template-element)
   */
  get-template-elements =
    {|Expanded:
      get-templates;
      filter(expand-single-line-template-production);
      choose-one-expansion
    |}

  choose-one-expansion =
       qsort(template-compare);
       Hd
    <+
       Hd

  /**
   * @type Any{Int} * Any{Int} -> Any
   *
   * The expansion with the least amount of literal characters is preferred.
   */
  template-compare:
    (x{x-score}, y{y-score}) -> <id>
    where
      <gti> (x-score, y-score)
    <+
      <eq> (x-score, y-score);
      <lti> (<template-character-count> x, <template-character-count> y)

  template-character-count =
    ?String(<string-length>)
    <+ ?Layout(<string-length>)
    <+ ?Text(<string-length>)
       // Penalty for unexpanded placeholders
    <+ \Placeholder(label, sort(x), _, <not(one(?Text(_)))>) -> <string-length> x\
    <+ crush(!0, addi, template-character-count)

  // lower than (does not exist in library)
  lti = not(gti)

module to-str

imports
  libstratego-lib
  libstratego-sglr
  libstrc
  include/TemplateLang
  templatelang/utils/attributes
  templatelang/utils/contract
  templatelang/utils/misc
  templatelang/utils/parse-str
  templatelang/desugar

rules

  template-sections-to-stratego(|languagename) =
    filter(template-section-to-stratego(|languagename))

  template-sections-to-stratego =
    filter(template-section-to-stratego)

  template-section-to-stratego(|languagename):
    TemplateSection(x) -> Strategies([s1*, s2*])
    where with-spxverify(
      s1* := <map(template-to-prettyprint-strategy)> x;
      s2* := <map(template-to-prettyprint-strategy(|languagename)); nub> x
      , !"Failed to convert TemplateSection to stratego pretty printer"
    )

  template-section-to-stratego(|languagename):
    SDFSection(lexical-syntax(x)) -> Strategies([s1*, s2*])
    where with-spxverify(
      x'  := <filter(templatelang-prod-to-sort); nub> x;
      s1* := <map(templatelang-sort-to-strategy)> x';
      s2* := <map(templatelang-sort-to-strategy(|languagename))> x'
      , !"Failed to convert lexical-syntax to stratego pretty printer"
    )

  template-section-to-stratego:
    TemplateSection(x) -> Strategies(s*)
    where with-spxverify(
      s* := <map(template-to-prettyprint-strategy)> x
      , !"Failed to convert TemplateSection to stratego pretty printer"
    )

  template-section-to-stratego:
    SDFSection(lexical-syntax(x)) -> Strategies(s*)
    where with-spxverify(
      x' := <filter(templatelang-prod-to-sort); nub> x;
      s* := <map(templatelang-sort-to-strategy)> x'
      , !"Failed to convert lexical-syntax to stratego pretty printer"
    )

rules

  templatelang-stratego-runtime-support(|module-name) =
    !|[ module ~module-name
        imports
          libstratego-lib
          libstratego-gpp

        signature
          constructors
            Parenthetical : Unknown -> Unknown

        strategies

          // Unwrap Parenthetical/1 if pp fails, in case the user is using
          // parenthesize, but grammar does not contain {bracket} production.
          pp-one(pp) = (pp <+ ?Parenthetical(<pp>)); filter(gpp-is-real-vbox)

          pp-one-V(pp) = pp-one(pp); (?[] <+ !V([], <id>))
          pp-one-Z(pp) = pp-one(pp); (?[] <+ !Z([], <id>))

          pp-option(pp) = \None() -> []\ + ?Some(<pp>)

          pp-V-list(pp)    = ?[] <+ !V([], <map(pp-one-V(pp))>)
          pp-V-list(pp|vs) = ?[] <+ !V([SOpt(VS(), vs)], <map(pp-one-V(pp))>)

          pp-indent(|is) = filter(gpp-is-real-vbox); (?[] <+ !I([SOpt(IS(), is)], H([SOpt(HS(), "0")], <id>)))

          pp-H-list(pp)     = ?[] <+ !H([], <map(pp-one-Z(pp))>)
          pp-H-list(pp|sep) = ?[] <+ !H([SOpt(HS(), "0")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

          pp-HV-list(pp)     = ?[] <+ !HV([SOpt(HS(), "0")], <map(pp-one-Z(pp))>)
          pp-HV-list(pp|sep) = ?[] <+ !HV([SOpt(HS(), "0")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)

          pp-HZ-list(pp)     = ?[] <+ !HZ([SOpt(HS(), "0")], <map(pp-one-Z(pp))>)
          pp-HZ-list(pp|sep) = ?[] <+ !HZ([SOpt(HS(), "0")], <map(pp-one-Z(pp)); separate-by(|S(sep))>)
    ]|

strategies

  templatelang-sort-to-strategy(|languagename):
    x ->
      SDefNoArgs(
          $[prettyprint-[languagename]]
          , CallNoArgs(SVar($[prettyprint-[x]]))
      )

  templatelang-sort-to-strategy:
    x ->
      SDefNoArgs(
          $[prettyprint-[x]]
          , Strategy |[ ![S(<is-string>)] ]|
      )

rules

  template-to-prettyprint-strategy(|languagename):
    Desugared(TemplateProduction(sort, SingleLineTemplate(elem*), attrs)) ->
      <template-to-prettyprint-strategy(|languagename)> Desugared(TemplateProduction(sort, Template([Line([Layout("") | elem*])]), attrs))

  template-to-prettyprint-strategy:
    Desugared(TemplateProduction(sort, SingleLineTemplate(elem*), attrs)) ->
      <template-to-prettyprint-strategy> Desugared(TemplateProduction(sort, Template([Line([Layout("") | elem*])]), attrs))

  template-to-prettyprint-strategy(|languagename):
    Desugared(TemplateProduction(x, Template(line*), attrs)) ->
      SDefNoArgs(
          $[prettyprint-[languagename]]
          , CallNoArgs(SVar($[prettyprint-[x]]))
      )

  template-to-prettyprint-strategy:
    Desugared(TemplateProduction(x, Template(line*), attrs)) ->
    // ${prettyprint-{sort}:
    //     {input} -> [{output}]}
      //RDefNoArgs(
      SDefNoArgs(
          $[prettyprint-[x]]
        // , RuleNoCond(NoAnnoList(input), NoAnnoList(List(output)))
          , Seq(Match(NoAnnoList(input)), Build(NoAnnoList(List(output))))
      )
    where with-spxverify(
      (line'*, _)    := <thread-map(rename-template-line)> (line*, 0);
      output         := <map(template-line-to-stratego)> line'*;
      arg*           := <mapconcat(template-line-to-cons-arg)> line'*;
      if cons := <fetch-cons-name> attrs then
        //input := $[[cons]([<separate-by(|",")> arg*])]
        input := Op(cons, arg*)
      else
        if !arg* => [_] then
          if <is-bracket> attrs then
            // bracket / parentheses
            input := Op("Parenthetical", arg*)
          else
            // injection
            // FIXME: this may result in infinite loop in pretty printer
            //        if there is a cycle of injections in the grammar!
            input := Var("a")
          end
        else
          input := Tuple(arg*)
        end
      end,
      !"Failed to pretty-print template"
    )

  template-to-prettyprint-strategy(|languagename) =
    templatelang-not-desugared(|"generate BOX-based pretty printer from")

  template-to-prettyprint-strategy =
    templatelang-not-desugared(|"generate BOX-based pretty printer from")

rules

  rename-template-line:
    (Line(elem*), index) -> (Line(elem'*), index')
    where with-spxverify(
      (elem'*, index') := <thread-map(try(rename-template-element))> (elem*, index),
      !"Failed to rename template elements"
    )

  rename-template-element:
    (Placeholder(a, b, c), index) -> (Placeholder(a, b, c){name'}, index')
    where with-spxverify(
      name'  := <implode-string> [<addi> ('a', index)];
      index' := <inc> index,
      !"Failed to rename template element"
    )

rules

  template-line-to-cons-arg:
    Line(elem*) -> <filter(template-element-to-cons-arg)> elem*

  template-element-to-cons-arg:
    Placeholder(_, _, _){name} -> Var(name)

rules

  template-line-to-stratego:
    Line([Layout(indent) | elem*]) ->
      // ${<pp-indent(|"{<string-length> indent}")> [{elem'*}]}
      App(
          CallT(SVar("pp-indent"), [], [NoAnnoList(Str(is))])
        , NoAnnoList(List(elem'*))
      )
      // Term |[ I([SOpt(IS(), t1)], H([SOpt(HS(), "0")], [t*])) ]|
    where
      not(!indent => "");
      not(!elem* => []);
      is := <string-length; int-to-string; double-quote> indent;
      elem'* := <template-line-elements-to-stratego> elem*

  template-line-to-stratego:
    Line([Layout("") | elem*]) -> Term |[ H([SOpt(HS(), "0")], [t*]) ]|
    where
      not(!elem* => []);
      t* := <template-line-elements-to-stratego> elem*

  template-line-to-stratego:
    // Include empty string element to prevent BOX from removing the empty H box!
    Line([Layout(_)]) -> Term |[ H([], [S("")]) ]|

  template-line-elements-to-stratego =
    // 1. Convert Layout to String.
    map(try(\Layout(t) -> String(t)\));
    // 2. Collapse consecutive Strings into single String.
    // (Optional, improves readability and performance of generated code.)
    concatenate-consecutive-strings;
    // 3. Map template elements to strings of Stratego code and String cons,
    //    while removing empty strings.
    // (The latter is necessary to prevent spurious blank lines:
    // BOX removes empty lists, but not empty string elements.)
    filter(template-element-to-stratego)

  template-element-to-stratego:
    String(t) -> Op("S", [NoAnnoList(Str(t'))])
    where
      not(!t => "");
      t' := <templatelang-escape; double-quote> t

  template-element-to-stratego:
    Placeholder(sort(x), None(), _){name} ->
      // $[<[s]> [name]]
      App(s, Var(name))
    where with-spxverify(
      placeholder-to-pp-one => s
      , !"Failed to determine placeholder type"
    )

  template-element-to-stratego:
    Placeholder(sort(x), Option(), _){name} ->
      // $[<pp-option([s])> [name]]
      App(Call(SVar("pp-option"), [s]), Var(name))
    where with-spxverify(
      placeholder-to-pp-one => s
      , !"Failed to determine placeholder type (option)"
    )

  placeholder-to-pp-one:
    Placeholder(sort(x), _, option*) ->
      // $[pp-one-[v-or-z](prettyprint-[x])]
      Call(ppo, [ppx])
    where with-spxverify(
      let anchor    = <one(?Anchor())> option*
          vbox-type = anchor < !"V" + !"Z"
      in
        ppo := SVar($[pp-one-[<vbox-type>]]);
        ppx := CallNoArgs(SVar($[prettyprint-[x]]))
      end
      , !"Failed to determine placeholder box type (V or Z)"
    )

  template-element-to-stratego:
    Placeholder(sort(x), <Star() + Plus()>, option*){name} ->
      // $[<[s]> [name]]
      // <pp-[h|v]-list(prettyprint-x)> name
      App(s, Var(name))
    where with-spxverify(
      let wrap      = <one(?Wrap())> option*
          anchor    = <one(?Anchor())> option*
          hbox-type = wrap < (anchor < !"HV" + !"HZ") + !"H"
          separator = <getfirst(?Separator(<id>))> option*
          ppl       = !SVar($[pp-[<hbox-type>]-list])
          ppx       = !CallNoArgs(SVar($[prettyprint-[x]]))
      in
        if separator => sep then
          switch <explode-string; occurrences(?'\n'); dec> sep => vs
            case ?-1:
              // separator without line breaks => horizontal box
              // s := $[pp-[h-or-hv-or-hz]-list(prettyprint-[x]|"[<templatelang-escape> sep]")]
              sep' := <templatelang-escape; double-quote> sep;
              s    := CallT(<ppl>, [<ppx>], [NoAnnoList(Str(sep'))])
            case ?0:
              // TODO: Support separators with mixed line breaks and literals.
              // separator with one line break => vertical box
              // s := $[pp-v-list(prettyprint-[x])]
              s := Call(SVar("pp-V-list"), [<ppx>])
            otherwise:
              // separator with multiple line breaks => vertical box with vs option
              // s := $[pp-v-list(prettyprint-[x]|"[vs]")]
              vs' := <int-to-string; double-quote> vs;
              s   := CallT(SVar("pp-V-list"), [<ppx>], [NoAnnoList(Str(vs'))])
          end
        else
          // no separator => horizontal box
          // s := $[pp-[h-or-hv-or-hz]-list(prettyprint-[x])]
          s := Call(<ppl>, [<ppx>])
        end
      end
      , !"Failed to convert list placeholder"
   )

rules

  // FIXME
  // Production without cons but with bracket annotation
  // (cons + bracket -> no need to parenthesize)
  // template-to-prettyprint-strategy:
  //   TemplateProduction(sort, Template(elem*), attrs) ->
  //   ${parenthesize-{sort}(not-allowed) =
  //       if not-allowed then
  //         <concat-strings> ["{open}", <prettyprint-{sort}>, "{close}"]
  //       else
  //         prettyprint-{sort}
  //       end}
  //   where
  //     not(<fetch-cons-name> attrs);
  //     FIXME <getfirst(?bracket())> attr*
  //   where
  //     <length> <filter(?Placeholder(_, _, _))> elem* => 1
  //     <+ debug(!"Bracket production must have exactly one placeholder: "); fail
  //   with
  //     (before, placeholder, after) := <split-fetch-keep(?Placeholder(_, _, _))> elem*
  //   where
  //     [String(open)]  := <map(template-element-to-stratego'); concatenate-consecutive-strings> before;
  //     [String(close)] := <map(template-element-to-stratego'); concatenate-consecutive-strings> after
  //     <+ debug(!"Bracket production must have text before and after the placeholder: "); fail

//   template-element-to-parenthesize(|conflicts):
//     (i0, Placeholder(sort(x), None(), _){name}) -> $[[name]' := <parenthesize-[x]([na])> [name]]
//     where
//       not(<filter(?(i0, <id>))> conflicts => conflicts' => [])
//     with
//       let to-match =
//             {a*: \ Symbol(x, n) -> <concat-strings> ["?", x, "(", a*, ")"]
//                    with a* := <range; map(!"_"); separate-by(|", ")> (0, n) \}
//       in
//         na := <filter(to-match); separate-by(|" + ")> conflicts'
//       end
//
//   template-element-to-parenthesize(|conflicts):
//     (i0, p@ Placeholder(sort(x), None(), _){name}) -> <template-element-to-prettyprint> p
//     where
//       <filter(?(i0, _))> conflicts => []
//
//   template-element-to-parenthesize(|conflicts):
//     (i0, p@ Placeholder(sort(x), <not(?None())>, _){name}) -> <template-element-to-prettyprint> p

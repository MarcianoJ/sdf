module to-parse-table

imports
	include/TemplateLang
	libstratego-sglr
	libstratego-lib
    libstratego-gpp
    generation/to-sdf
    lib/runtime/nabl/-
    src-gen/pp/TemplateLang-pp
    
overlays
	sdf-norm-constructor(s) = Term(Default(Appl(Unquoted("default"),[Appl(Unquoted("appl"),[Appl(Unquoted("unquoted"),[Fun(Quoted("\"cons\""))]),List([List([Appl(Unquoted("fun"),[Appl(Unquoted("quoted"),[Fun(Quoted(s))])])])])])])))    
    
signature 
	constructors
	
	ItemSets : List(Label) * List(ItemSet) -> ItemSets
	ItemSet  : Label * List(Item) * List(goto) * Completions -> ItemSet
	Completions : List(CompletionItem) -> Completions
	CompletionItem : Sort * Description * String -> CompletionItem
	Item : List(Symbol) * List(Symbol) * Symbol * Label -> Item
	Changed    : Status
	NotChanged : Status
	
// are theses constructors in some stratego library?	
// TODO: Define a syntax definition for the parse-table
signature
   constructors	
   
   parse-table  : version * initialState * List(Label) * states * priorities -> ParseTable
   states       : List(State) -> States
   priorities   : List * Priorities -> Priorities
   arg-gtr-prio : Label * Arg * Label -> arg-gtr-prio
   grt-prio     : Label * Label -> arg-gtr-prio
   goto         : List(Int) * Label -> goto
   state-rec    : Label * List(goto) * List(action) -> state-rec
   action       : List(Int) * List(actions) -> action
   shift        : Int -> shift
   reduce       : Arity * Label * Status -> reduce 
   accept       : accept
   
   

   
rules
	
	to-parse-table:
		m@Module(Unparameterized(mn), [], sections*) -> parse-table(version, initialstate, labels*, states, priorities(priorities'))
		with
		    <set-counter> ("labels", 256);
			version := <!6> ; //maybe 7, then?
			initialstate := <!0>;
			prods* := <get-normalized-productions> sections*;
			table-prods* := <filter(prod-to-pt-format)> prods*;
     		labels*      := <map(create-label); reverse> table-prods*;
     		<create-symbols-sets(|table-prods*)> table-prods*;
			item-sets*   := <to-item-sets(|labels*, table-prods*)> m;
			states       := <create-states> item-sets*;
			priorities   := <get-normalized-priorities > sections*;
			priorities'  := <map(priority-to-label)> priorities
			
	create-symbols-sets(|p*) = set-flag-true; repeat(calculate-sets-prods(|p*)) 
	
	
	//while flag-is-true calculate first-sets for each production	
	calculate-sets-prods(|p*) = where(check-flag; set-flag-false; map(calculate-sets(|p*)))		
	
	check-flag = where(get-flag; ?Changed())
	
	set-flag-false = where(rules(get-flag : t -> NotChanged()))
	
	set-flag-true = where(rules(get-flag : t -> Changed()))
			
	calculate-sets(|prods*):
		p@prod(rhs*, symbol, attrs*) -> <id>
		where
			// k=0 then symbol is nullable
			if [] := rhs* then
				if not("true" := <is-nullable> symbol) then
					set-flag-true;
					rules(
						is-nullable:
							symbol -> "true"											
					)
				end
			end;
			
			// if rhs* are all nullable
			if <check-all-symbols-nullable> rhs* then
				if not("true" := <is-nullable> symbol) then
					set-flag-true;
					rules(
						is-nullable:
							symbol -> "true"
						)
				end
			end;
			
			
			first-set := <bagof-get-first-set-symbol> symbol;
			// try to add the first set of the first symbol on the rhs to symbol
			<add-first-from-list(|first-set, symbol)> rhs*;			
			//try to add the first set of the nullable following symbols
			<add-first-nullable(|first-set, symbol)> rhs*
			;<bagof-get-first-set-symbol> symbol
			
			;  label-p := <get-label-from-prod> p
			; <filter(calculate-follow(|p, symbol))> prods*
			 
	
			
	calculate-follow(|orig, s):
		new@prod(rhs*, symbol, attrs*) -> <id>
		where
			<follow-from-production(|orig, s, new)> rhs*
	
	follow-from-production(|orig, s, new):
		[h | hs] -> <id>
		where
			if <?s> h then
				if <check-all-symbols-nullable> hs then
					//if all symbols are nullable, then add follow from prod that produced this rhs
					<add-follow-from-prod(|orig)> new
				end;
					//add the next symbol and the followings if the next is nullable 
				<add-follow-nullable(|orig)> hs
			end;
			<follow-from-production(|orig, s, new)> hs
	
	//if there is no symbol do nothing		
	add-follow-nullable(|orig):
		[] -> <id>
		
	add-follow-nullable(|orig):
		[h | hs] -> <id>
		where
			symbols* := <get-first-set> h; //add-first-h
			<filter(add-symbols-to-follow-set(|orig))> symbols*;
			if <is-nullable> h then
				<add-follow-nullable(|orig)> hs
			end
			
	add-symbols-to-follow-set(|orig):
		symbol -> <id>
		where
			label-orig := <get-label-from-prod> orig;
			follow-set := <bagof-get-follow-set-from-prod> label-orig;
			if <not(fetch(?symbol))> follow-set then
				set-flag-true;
				rules(				
				get-follow-set-from-prod:+
					label-orig -> symbol							
				)
			end
			
	add-follow-from-prod(|orig):
		new -> <id>
		where
			label-new := <get-label-from-prod> new;
			symbols* := <bagof-get-follow-set-from-prod> label-new;
			<filter(add-symbols-to-follow-set(|orig))> symbols*		
				
	
	//if there is no symbol do nothing
	add-first-nullable(|first-set, s):
		[] -> <id>
	
	//if there is a symbol	
	add-first-nullable(|first-set, s):
		[h | hs] -> <id>
		where
		if <is-nullable> h then
			<add-first-from-list(|first-set, s)> hs;
			<add-first-nullable(|first-set, s)> hs
		end
		
	//if there is no symbol do nothing
	add-first-from-list(|first-set, s):
		[] -> <id>
		
	//if there is a symbol
	add-first-from-list(|first-set, s):
		[h | hs] -> <id>
		where
		//get first set of symbol h
		symbols* := <get-first-set> h;		
		//try to add new symbols to first-set of s
		<filter(add-symbols-to-first-set(|first-set, s))> symbols*
		 
	add-symbols-to-first-set(|first-set, s):
		symbol -> <id> 
	where
		if <not(fetch(?symbol))> first-set then
			set-flag-true;
			rules(				
				get-first-set-symbol:+
					s -> symbol							
			)
		end 
	
	get-first-set = get-first-set-cc <+ bagof-get-first-set-symbol	

    get-first-set-cc:
		char-class(cc) -> cc
		
	check-all-symbols-nullable = map(is-nullable)		
	
	calculate-symbols-first-set:
		[h | s] -> symbols'*
		with
			symbols* := <get-first-set> h;
			if <is-nullable> h then
				remainder* := <calculate-symbols-first-set> s;
				symbols'*  := [symbols*, remainder*]
			else
				symbols'* := symbols*
			end
			
	calculate-symbols-first-set:
		[] -> []			 		
				 
			

	
	
	create-label:
		prod@prod(rhs*, symbol, attrs*) -> label(prod, label-num)
		with			
			label-num := <next-counter> "labels";
					
			rules(
				get-label-from-prod:
				prod -> label-num
				
				get-prod-from-label:
				label-num -> prod
				
				get-prods-from-symbol:+
				symbol -> prod
				
				//TODO: Figure out which status numbers correspond to avoid, prefer, reject 
				get-status-from-label:
				label-num -> 0
				
				
				)
				
	
	//does the production in here need to be in that specific format?
	prod-to-pt-format :
		sdfprod@SdfProduction(symbol, Rhs(rhs*), attrs) -> table-prod
		with
			rhs'*   := < filter(symbol-to-pt-format)> rhs*;
			symbol' := <symbol-to-pt-format> symbol;
			attrs' := <?Attrs([]); !no-attrs() <+ ?Attrs(<id>); !attrs(<filter(attrs-to-pt-format)>)> attrs;
			table-prod := prod(rhs'*, symbol', attrs');
			attrs-sdf := <?Attrs([]); !NoAttrs() <+ id> attrs;
			rules(
				get-sdf-prod-from-prod :
					table-prod -> SdfProduction(symbol, Rhs(rhs*), attrs-sdf)
			)
			
	
	symbol-to-pt-format = special-symbol-to-pt-format <+ term-translation
	
	special-symbol-to-pt-format:
		FileStart() -> sort("<Start>")
		
	special-symbol-to-pt-format:
		Start() -> sort("<START>")	
		
	special-symbol-to-pt-format:
		Lit(s) -> lit(<un-double-quote; unescape> s)	
		
	special-symbol-to-pt-format:
		CiLit(s) -> ci-lit(<un-double-quote; unescape> s)
		
	special-symbol-to-pt-format:
	 	CharClass(Simple(Present(char-class))) -> char-class([n'*])
	 	with
	 	n'* := <char-class-to-pt-format> char-class 
	 	
	 
	char-class-to-pt-format:
		Numeric(n) -> [n']
		with 
	 	int := <ltrim-chars(?'\')> n;
	 	n'  := <string-to-int> int
	
	char-class-to-pt-format:
		Range(Numeric(n1), Numeric(n2)) -> [range(n1', n2')]
		with
		int1 := <ltrim-chars(?'\')> n1;
	 	n1'  := <string-to-int> int1;
	 	int2 := <ltrim-chars(?'\')> n2;
	 	n2'  := <string-to-int> int2
	 	
	
	char-class-to-pt-format:
		Conc(cc1, cc2) -> [cc1*, cc2*]
		with
		cc1* := <char-class-to-pt-format> cc1;
		cc2* := <char-class-to-pt-format> cc2
	
	 	 	
	attrs-to-pt-format = special-attrs-to-pt-format <+ term-translation
		
		
	special-attrs-to-pt-format:
		Term(Default(Appl(Unquoted("default"),[Appl(Unquoted("appl"),[Appl(Unquoted("unquoted"),[Fun(Quoted("\"cons\""))]),List([List([Appl(Unquoted("fun"),[Appl(Unquoted("quoted"),[Fun(Quoted(s))])])])])])])))	
 -> term(cons(<un-double-quote; unescape> s))
 
		
	priority-to-label:
		Chain([group1, group2]) -> arg-gtr-prio(label1, arg', label2)
	where
		oncetd(?WithArguments(_, Default([arg])))
	with
	    arg'   := <string-to-int> arg ;
		label1 := <get-label-from-group> group1;
		label2 := <get-label-from-group> group2
	
	get-label-from-group :
		NonTransitive(WithArguments(g, Default([arg]))) -> label
		with
		label := <get-label-from-group> g
	
	get-label-from-group :
		SimpleGroup(prod) -> label
		with
		label := <prod-to-pt-format; get-label-from-prod> prod
			
	create-states:
		ItemSets(labels*, item-set*) -> states(states'*)
		with
		actions-hash := <new-hashtable>;
		states* := <filter(create-state-from-itemset(|actions-hash))> item-set*;
		states'* := <isort-list(LSort(compare-states))> states*
		
	compare-states = ?(s1@state-rec(label1, _, _), s2@state-rec(label2, _, _)); !(label1, label2); gt
		
	create-state-from-itemset(|actions-hash):
		ItemSet(label, items*, gotos*, completions) -> state-rec(label, gotos*, actions*)
		with
		   <hashtable-clear> actions-hash;
		   <filter(create-action-from-item(|gotos*, actions-hash))> items*;
		   keys* := <hashtable-keys> actions-hash;
		   actions* := <map(create-action-from-key(|actions-hash))> keys*
		   		
	create-action-from-key(|actions-hash):
		key -> action(key, value)
		with
		value := <hashtable-get(|key)> actions-hash
		   
	create-action-from-item(|gotos*, actions-hash):
		Item(beforeDot, [char-class(cc) | hs], symbol, label) -> action(cc, [shift(state)])
		where
			not(<?([sort("<START>")], char-class(cc))> (beforeDot, char-class([256])))
		with
			goto := <fetch(?goto(cc, state))> gotos* ;
			<hash-multimap-putlist(|cc, [shift(state)])> actions-hash
			   
	create-action-from-item(|gotos*, actions-hash):
		Item([sort("<START>")], [char-class([256])], symbol, label) -> action([256], [accept()])
		with
			<hash-multimap-putlist(|[256], [accept()])> actions-hash
	
	create-action-from-item(|gotos*, actions-hash):
		Item(beforeDot*, [], symbol, label) -> action(followset, [reduce(<length> beforeDot*, label, status)])
		where
			not(<?[sort("<START>"), char-class([256])]> beforeDot*)
		with
		status    := <get-status-from-label> label;
		followset := <bagof-get-follow-set-from-prod; sort-list(LSort(gt))> label;
		<hash-multimap-putlist(|followset, [reduce(<length> beforeDot*, label, status)])> actions-hash
		 
	
	
	
	get-normalized-productions = oncetd(?Kernel(prods*)); !prods*
	get-normalized-priorities  = oncetd(?Priorities(priorities*)); !priorities*
	
	
	to-item-sets(|labels*, prods*):
		Module(Unparameterized(mn), i*, sections*) -> ItemSets(labels*, items*)
		with
			initial-item  :=  <get-initial-prod; make-new-item-from-prod> prods*;
			<set-counter> ("state-labels", -1);
			initial-items* := <calculate-closure(|[]); flatten-list> initial-item;
			initial-state := ItemSet(<next-counter> "state-labels", initial-items*, [], Completions([]));
			items* := <calculate-item-sets> initial-state 
	
	//is the initial prod always the last?			
	get-initial-prod = last		
	
	to-item-sets:
		Module(Unparameterized(mn), i*, sections*) -> ItemSets(labels*, items'*)
		with
		    <set-counter> ("labels", 256);
		    <set-counter> ("state-labels", -1);
			prods* := <get-normalized-productions> sections*;
			table-prods* := <filter(prod-to-pt-format)> prods*;
			labels*      := <map(create-label); reverse> table-prods*;			
			initial-item  :=  <get-initial-prod; make-new-item-from-prod> table-prods*;
			initial-items* := <calculate-closure(|[]); flatten-list> initial-item;
			initial-state := ItemSet(<next-counter> "state-labels", initial-items*, [], <get-completions-from-items> initial-items*);
			items* := <calculate-item-sets> initial-state; 
			items'* := <isort-list(LSort(compare-item-sets))> items*
	
	compare-item-sets = ?(i1@ItemSet(label1, _, _, _), i2@ItemSet(label2, _, _, _)); !(label1, label2); gt
	
	calculate-closure(|symbols*):
		i@Item(beforeDot, [h | hs], symbol, label) -> new-items*
		where
			<not(fetch(?h))> symbols*
		with
			prods* := <bagof-get-prods-from-symbol> h;
			prods-restrained* := prods*; // TODO: Consider priorities when calculating the closure <filter(check-for-priorities)> prods*;
			new-items-from-prods* := <map(make-new-item-from-prod)> prods-restrained*;
			new-items* := [i, <map(calculate-closure(|[h, symbols*]) <+ id ) > new-items-from-prods*]
			
	calculate-closure(|symbols*):
			i@Item(beforeDot, [], symbol, label) -> i
			
	calculate-item-sets:
		ItemSet(label, items*, gotos, completions) -> new-states*
	where
		<not(expanded-state)> label;
		rules(
			expanded-state:
			label -> <id>
		)
	with
	    new-states-goto-prods* := <filter(shift-item(|items*))> items*;
	    derived-states-prods*  := <filter(?(<id>,goto(_,_)))> new-states-goto-prods*;
	    derived-gotos-prods*   := <filter(?(ItemSet(_, _, _, _),<id>))> new-states-goto-prods*;
	    new-states-goto-cc*    := <filter(shift-cc(|items*))> items*;
	    derived-states-cc*     := <filter(?(<id>,goto(_,_)))> new-states-goto-cc*;
	    derived-gotos-cc*      := <filter(?(ItemSet(_, _, _, _),<id>))> new-states-goto-cc*;
	    derived-states*       := [derived-states-prods*, derived-states-cc*];
	    new-item-sets* := <filter(calculate-item-sets); flatten-list> derived-states*; 
		new-states* := [ItemSet(label, items*, [derived-gotos-prods*, derived-gotos-cc*], completions), new-item-sets*]
	
	shift-cc(|items*):
		Item(beforeDot*, [char-class(cc) | hs ], symbol, label) -> (new-state, goto)
		with
		new-state  := <filter(shift-charclass(|cc); calculate-closure(|[])); flatten-list; make-new-state> items*;
		state-label := <?ItemSet(<id>, _, _, _)> new-state;
		goto      := goto(cc, state-label)
		
	shift-charclass(|cc):
		Item(beforeDot*, [h | hs], symbol, label) -> Item([beforeDot*, h], hs, symbol, label)
		where
		<?char-class(cc)> h
		
	shift-item(|items*):
		i@Item([], afterDot*, symbol, label) -> (new-state, goto)
		with
		   new-state := <filter(shift-symbol(|symbol); calculate-closure(|[])); flatten-list; make-new-state> items*;
		   state-label := <?ItemSet(<id>, _, _, _)> new-state;
		   goto      := goto([label], state-label)
		   
		
	shift-symbol(|s):
		Item(beforeDot*, [h | hs], symbol, label) -> Item([beforeDot*, h], hs, symbol, label)
	where
		<?s> h
		
	make-new-state:
		items* -> ItemSet(label, items*, [], completions)
		with
			label := <get-label-from-items <+ <next-counter> "state-labels">;
			completions := <get-completions-from-items; debug(!"completions ")> items*;
			rules(
				get-label-from-items:
					items* -> label
			)
			
	get-completions-from-items:
		items* -> Completions(completions*)
		where
		completions* := <debug(!"items "); filter(item-to-completion)> items*
		
	item-to-completion :
		Item(beforeDot*, [h | hs], symbol, label) -> CompletionItem(symbol, completion-description, completion-string)
	where
		sdfProd := <get-prod-from-label; get-sdf-prod-from-prod> label;
		<?SdfProduction(_, _, Attrs(<fetch(get-norm-constructor)>)) <+ <?lit(_)> symbol> sdfProd;
	    completion-description := <prettyprint-SdfProduction;  !V([], <id>); box2text-string(|120); debug(!"completion description ")> sdfProd;
		completion-string := <map(symbol-to-completion-string); flatten-list; debug(!"resulting strings "); concat-strings; trim-chars(?' '); debug(!"completion string ")> [h | hs]
		
	symbol-to-completion-string:
		sort(s) -> <conc-strings> (s, " ")
	
	symbol-to-completion-string:
		lit(s) -> <conc-strings> (<double-quote> s, " ")
	
	symbol-to-completion-string:
		ci-lit(s) -> <conc-strings> (<single-quote> s, " ")
	
	symbol-to-completion-string:
		lex(s) -> <symbol-to-completion-string> s
	
	symbol-to-completion-string:
		cf(s) -> <symbol-to-completion-string> s	
		
	symbol-to-completion-string:
		layout() -> " "
		
	symbol-to-completion-string:
		opt(s) -> <symbol-to-completion-string> s
		
	symbol-to-completion-string:
		char-class(cc) -> <map(char-class-to-string)> cc	
		
	char-class-to-string:
		cc -> <implode-string> [cc]
	where
		not(?range(_, _)); is-int;
		not(<?256> cc) 
		
	char-class-to-string:
		range(cc, cc2) -> <implode-string> [cc, cc2]	
	
	
					
		
	make-new-item-from-prod:
		p@prod(rhs*, symbol, attrs'*) -> Item([], rhs*, symbol, label)
		with
		label := <get-label-from-prod> p
			
			
	get-norm-constructor:
		Term(Default(Appl(Unquoted("default"),[Appl(Unquoted("appl"),[Appl(Unquoted("unquoted"),[Fun(Quoted("\"cons\""))]),List([List([Appl(Unquoted("fun"),[Appl(Unquoted("quoted"),[Fun(Quoted(s))])])])])])]))) -> s
			
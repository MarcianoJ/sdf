// changes in the SDF3 grammar:
// ID => Sort (ID could produce a sort starting with a lower case letter)
// removed the parametrized sorts replacing them with the actual sorts from the SDF grammar
// STRING replaced by StrCon from SDF2 Grammar
// The Syntax grammar couldnot be translated to SDF3 due SDF3 only allow sorts, and not symbols in its productions
// Merged Backslash1 and Backslash2 into backslash
// The restrictions for module names (SPXCommon) are in Sdf2.sdf3
// Sections are defined in Modules.sdf3

module TemplateLang
imports
  sdf2-core/SDF
  
//main productions to link SDF2 and SDF3
context-free start-symbols
    Start

templates
Start.CompilationUnit = <<Section*>> {deprecated("Syntax definitions should be part of a module")}

templates
Attribute.QuotedConstructor = <<QuotedConstructor>> {prefer}
QuotedConstructor = <<StrCon>>  

templates
//tweaks for content completion
TemplateProduction.WATER = <<CONTENTCOMPLETE>> {recover}
PlaceholderOption.WATER = <<CONTENTCOMPLETE>> {recover}
PlaceholderOptions.WATER = <<CONTENTCOMPLETE>> {recover}

templates
//options section
Section.TemplateOptions = <template options <TemplateOption*>>

TemplateOption.Newlines = <newlines : <NewlineOptionValue>>

NewlineOptionValue.None = <none>
NewlineOptionValue.Leading = <leading>
NewlineOptionValue.Trailing = <trailing>
NewlineOptionValue.Separating = <separating>

TemplateOption.KeywordFollowRestriction = <keyword -/- <Lookaheads>>

TemplateOption.Tokenize = <tokenize : <StrCon>>

templates
//references to productions using sort.cons notation in priority specification
Group.SimpleRefGroup = <<SortConsRef>>
Group.ProdsRefGroup = <{<SortConsRef+>}>
Group.AssocRefGroup = <{<Associativity> : <SortConsRef+>}>
SortConsRef.SortConsRef = <<Sort>.<Constructor>>

templates 
//grammars
Section.TemplateSection = <templates <TemplateProduction*>>

// BNF order and SDF order can't go together in the same section,
// because of ambiguity. "X = Y -> Z": is it "X = Y" "Z" or "X =" "Y -> Z"?
Grammar.LexicalSyntax = <lexical syntax <SdfProduction*>> {prefer}
Grammar.ContextFreeSyntax = <context-free syntax <SdfProduction*>> {prefer}
Grammar.Kernel = <syntax <SdfProduction*>> {prefer}

// syntactic sugar for SDF
SdfProduction.SymbolSdfProduction = <<Symbol> = <RHS> <Attributes>> 
SdfProduction.SortKernelProduction = <<KernelSort> = <RHS> <Attributes>> {prefer}
SdfProduction.SdfProduction = <<Sort> = <RHS> <Attributes>> {prefer}
SdfProduction.SdfProductionWithCons = <<SortCons> = <RHS> <Attributes>>
RHS.Rhs = <<Symbols>>

// template productions
TemplateProduction.TemplateProduction = <<Sort> = <Template> <Attributes>>

// template productions Sort.Cons = ...
TemplateProduction.TemplateProductionWithCons = <<SortCons> = <Template> <Attributes>>

Constructor.Constructor = <<IdCon>>

SortCons.SortCons = <<Sort>.<Constructor>>


// placeholders
TemplatePart1 = <\<<Placeholder>\>> {bracket}
// should we use square brackets?
TemplatePart2 = <[<Placeholder>]> {bracket}

//Probably fix this to avoid <Sort*; separator="c">
Placeholder.Placeholder = <<PlaceholderLabel> <PlaceholderSort> <PlaceholderSuffix> <PlaceholderOptions>>

PlaceholderSort.Sort = <<Sort>>

PlaceholderLabel.None = <>
PlaceholderLabel.Label = <<Label>:>

//Probably define this rules using SDF2 style, merging PlaceholderSort PlaceholderSuffix -> PlaceholderSort
PlaceholderSuffix.None = <>
PlaceholderSuffix.Star = <*>
PlaceholderSuffix.Plus = <+>
PlaceholderSuffix.Option = <?>

PlaceholderOptions.NoOptions = <>
PlaceholderOptions.Options = <; <PlaceholderOption+; separator=",">>

PlaceholderOption.Hide = <hide>
PlaceholderOption.Wrap = <wrap>
PlaceholderOption.Anchor = <anchor>
//mark as deprecated
PlaceholderOption.Separator = <separator = <StrCon>>
PlaceholderOption.Text = <text = <StrCon>>

//this section probably should be rules for a normalized SDF3 grammar
//these rules cannot be translated to templates because placeholders only accept sorts
  syntax
    %% template parts
    "<" {<TemplateLine1-CF> "\n"}+ ">" -> <Template-CF> {cons("Template")}
    "<<" {<TemplateLine1-CF> "\n"}+ ">>" -> <Template-CF> {cons("Template"), avoid, deprecated("Use single brackets to delimit the template")}
    <TemplatePart1-CF>* -> <TemplateLine1-CF> {cons("Line")}
    <TemplateString1-LEX> -> <TemplatePart1-CF> {cons("String")}
    <TemplateEscape1-LEX> -> <TemplatePart1-CF> {cons("Escape")}
    <TemplateLayout-LEX>  -> <TemplatePart1-CF> {cons("Layout")}

    "[" {<TemplateLine2-CF> "\n"}+ "]" -> <Template-CF> {cons("Template")}
    "[[" {<TemplateLine2-CF> "\n"}+ "]]" -> <Template-CF> {cons("Template"), avoid, deprecated("Use single brackets to delimit the template")}
    <TemplatePart2-CF>* -> <TemplateLine2-CF> {cons("Line")}
    <TemplateString2-LEX> -> <TemplatePart2-CF> {cons("String")}
    <TemplateEscape2-LEX> -> <TemplatePart2-CF> {cons("Escape")}
    <TemplateLayout-LEX>  -> <TemplatePart2-CF> {cons("Layout")}

    %% special: no placeholders, no newlines
    '"' <TemplatePartQ-CF>* '"' -> <Template-CF> {cons("SingleLineTemplate")}
    <TemplateStringQ-LEX> -> <TemplatePartQ-CF> {cons("String")}
    <TemplateEscapeQ-LEX> -> <TemplatePartQ-CF> {cons("Escape")}
    <TemplateLayout-LEX>  -> <TemplatePartQ-CF> {cons("Layout")}

  lexical syntax
    "\n" = [\r\n] //this rule is not allowed in SDF3 yet
    TemplateLayout =  [\ \t]+
    
    TemplateString1 = (~[\\\<\>\ \t\r\n] | Backslash)+
    TemplateString2 = (~[\\\[\]\ \t\r\n] | Backslash)+
	TemplateStringQ =  ~[\\\"\ \t]+   
   

	Backslash = [\\] 
    // [\\] -> Backslash1
    // [\\] -> Backslash2      => [\\] -> Backslash

  lexical restrictions
    TemplateLayout -/- [\ \t]

    %% must be followed by:
    TemplateString1 -/- ~[\\\<\>\ \t\r\n]
    TemplateString2 -/- ~[\\\[\]\ \t\r\n]
    TemplateStringQ -/- ~[\\\"\ \t]

    %% if followed by a backslash, then the backslash must be followed by:
    TemplateString1 -/- [\\].~[\<\>\\]
    TemplateString2 -/- [\\].~[\[\]\\]

    Backslash -/- [\<\>\\]
   

  lexical syntax
  //production for ContenteCompletion
  CONTENTCOMPLETE = [a-zA-Z]* "CONTENTCOMPLETE" [0-9]+  {avoid}
  
  //combine sequences of escaped chars
  TemplateEscape1 = EscapedChar1+
  TemplateEscape2 = EscapedChar2+
  
  //this are the escapes which StringTemplate has
  EscapedChar1 = "\\<"
  EscapedChar1 = "\\>"
  EscapedChar1 = "\\\\"
  EscapedChar2 = "\\["
  EscapedChar2 = "\\]"
  EscapedChar2 = "\\\\"
  
   EscapedChar1 = "<" (EscapedBackslashChar1 | EscapedChar)* ">"
   EscapedChar1 = "<\\\\>" [\ \t\r]* [\n]
   EscapedChar2 = "[" (EscapedBackslashChar2 | EscapedChar)* "]"
   EscapedChar2 = "[\\\\]" [\ \t\r]* [\n]

    // double-backslash isn't allowed as sole member of escape placeholder
    // (would clash with <\\> / [\\] line continuation construct)
    // so we add follow restrictions to the following symbols:
   EscapedBackslashChar1 = "\\\\"
   EscapedBackslashChar2 = "\\\\"
   
   TemplateEscapeQ = ("\\\\" | EscapedChar)+
   
   //escapes allowed in a placeholder-like construct
   EscapedChar = "\\'"
   EscapedChar = '\\"'
   EscapedChar =  "\\ "
   EscapedChar =  "\\t"
   EscapedChar =  "\\r"
   EscapedChar =  "\\n"
    
    
    
    EscapedUnicodeChar = "\\u" [0-9A-Fa-f]+ 
    EscapedChar = EscapedUnicodeChar
    
    EscapedChar.WATER = "\\" ~[] {recover}
    EscapedChar1.WATER = "<" ~[\>]+ ">" {recover}
    EscapedChar2.WATER = "[" ~[\]]+ "]" {recover}


  lexical restrictions
    TemplateEscape1 -/- [\\]
    TemplateEscape1 -/- [\<].[\\\>]
    TemplateEscape2 -/- [\\]
    TemplateEscape2 -/- [\[].[\\\]]
    TemplateEscapeQ -/- [\\]
    EscapedBackslashChar1 -/- [\>]
    EscapedBackslashChar2 -/- [\]]
    EscapedUnicodeChar -/- [0-9A-Fa-f]

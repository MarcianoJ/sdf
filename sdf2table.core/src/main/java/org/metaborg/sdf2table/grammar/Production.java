package org.metaborg.sdf2table.grammar;

import java.util.List;
import java.util.Set;

import org.metaborg.sdf2table.core.FixPointMember;
import org.metaborg.sdf2table.core.Utilities;
import org.metaborg.sdf2table.parsetable.ContextualProduction;
import org.metaborg.sdf2table.parsetable.ContextualSymbol;
import org.metaborg.sdf2table.parsetable.Label;
import org.metaborg.sdf2table.parsetable.ParseTable;
import org.metaborg.sdf2table.symbol.NonTerminal;
import org.metaborg.sdf2table.symbol.Symbol;
import org.metaborg.sdf2table.symbol.Terminal;
import org.metaborg.sdf2table.symbol.TerminalContainer;

public abstract class Production{
	static final FirstSetFactory fs_factory = new FirstSetFactory();
	
	public enum AssocType{
		LEFT,
		RIGHT,
		NON_ASSOC
	}
	
	public enum AttributeType{
		DEPRECATED, // see Deprecated
		
		REJECT,
		PREFER,
		AVOID,
		
		ASSOC, // see Associativity
		
		BRACKET,
		
		LAYOUT_CONSTRAINT, // see LayoutConstraint
		IGNORE_LAYOUT,
		ENFORCE_NEWLINE,
		
		LONGEST_MATCH,
		CASE_INSENSITIVE,
		
		PLACEHOLDER,
		PLACEHOLDER_INSERTION,
		LITERAL_COMPLETION
	}
	
	public static class Attribute{
		AttributeType _type;
		
		public Attribute(AttributeType type){
			_type = type;
		}
		
		public AttributeType type(){
			return _type;
		}
		
		public String name(){
			switch(_type){
			case REJECT:
				return "reject";
			case PREFER:
				return "prefer";
			case AVOID:
				return "avoid";
			case BRACKET:
				return "bracket";
			case IGNORE_LAYOUT:
				return "ignore-layout";
			case ENFORCE_NEWLINE:
				return "enforce-newline";
			case LONGEST_MATCH:
				return "longest-match";
			case CASE_INSENSITIVE:
				return "case-insensitive";
			case PLACEHOLDER:
				return "placeholder";
			case PLACEHOLDER_INSERTION:
				return "placeholder-insertion";
			case LITERAL_COMPLETION:
				return "literal-completion";
			default:
				break;
			}
			
			return "";
		}
		
		@Override
		public int hashCode(){
			return _type.hashCode();
		}
		
		@Override
		public boolean equals(Object other){
			if(other != null && other instanceof Attribute){
				Attribute attr = (Attribute)other;
				return _type.equals(attr._type);
			}
			
			return false;
		}
	}
	
	public static class Associativity extends Attribute{
		AssocType _assoc;
		
		public Associativity(AssocType assoc){
			super(AttributeType.ASSOC);
			_assoc = assoc;
		}
		
		public AssocType assoc(){
			return _assoc;
		}
		
		@Override
		public String name(){
			switch(_assoc){
			case LEFT:
				return "left";
			case RIGHT:
				return "right";
			case NON_ASSOC:
				return "non-assoc";
			}
			
			return "";
		}
		
		@Override
		public int hashCode(){
			return Utilities.hashCode(_type.hashCode(), _assoc.hashCode());
		}
		
		@Override
		public boolean equals(Object other){
			if(other != null && other instanceof Associativity){
				Associativity attr = (Associativity)other;
				return _assoc.equals(attr._assoc);
			}
			
			return false;
		}
	}
	
	public static class Deprecated extends Attribute{
		String _message;
		
		public Deprecated(String message){
			super(AttributeType.DEPRECATED);
			_message = message;
		}
		
		public String message(){
			return _message;
		}
		
		@Override
		public String name(){
			return "deprecated";
		}
		
		@Override
		public int hashCode(){
			return Utilities.hashCode(_type.hashCode(), _message.hashCode());
		}
		
		@Override
		public boolean equals(Object other){
			if(other != null && other instanceof Deprecated){
				Deprecated attr = (Deprecated)other;
				return _message.equals(attr._message);
			}
			
			return false;
		}
	}
	
	public static class LayoutConstraint extends Attribute{
		String _constraint;
		
		public LayoutConstraint(String constraint){
			super(AttributeType.LAYOUT_CONSTRAINT);
			_constraint = constraint;
		}
		
		public String constraint(){
			return _constraint;
		}
		
		@Override
		public String name(){
			return "layout("+_constraint+")";
		}
		
		@Override
		public int hashCode(){
			return Utilities.hashCode(_type.hashCode(), _constraint.hashCode());
		}
		
		@Override
		public boolean equals(Object other){
			if(other != null && other instanceof LayoutConstraint){
				LayoutConstraint attr = (LayoutConstraint)other;
				return _constraint.equals(attr._constraint);
			}
			
			return false;
		}
	}
	
	int _hash_code = -1;
	
	FixPointMember<TerminalContainer, FirstSet> _first_set = new FixPointMember<>(new TerminalContainer());
	
	/**
	 * FOLLOW(this).
	 * <p>
	 * This set is not computed until {@link Syntax#computeFollowSets()} has not been called.
	 */
	FixPointMember<TerminalContainer, FirstSet> _follow_set = new FixPointMember<>(new TerminalContainer());
	
	/**
	 * Compute direct dependencies generated by this production.
	 * <p>
	 * For a production P = "A0 A1 ... An -> B", the set of direct dependencies is decided as follow:
	 * 
	 * 1. if P is empty then FIRST(P) depends on FOLLOW(P).
	 * 2. if A0 if a non-terminal then for all production Q that produce A0 and does not conflict P at position 0, FIRST(P) depends on FIRST(Q).
	 * 3. for all Ai of P,
	 * 		if i < n then for all production Q that produce Ai+1 and does not conflict P at position i+1, FOLLOW(Ai) depends on FIRST(Q).
	 * 		if i = n then FOLLOW(Ai) depends on FOLLOW(P).
	 */
	public void computeDependencies(){
		// FIRST(this) dependencies
		if(isEmpty()){
			_first_set.addDependency(_follow_set);
		}else{
			Symbol sym = symbol(0);
			
			if(sym instanceof Terminal){
				_first_set.initialValue().add((Terminal)sym);
			}else{
				for(Production p : ((NonTerminal)sym).productions()){
					if(!shallowConflicts(p, 0))
						_first_set.addDependency(p._first_set);
				}
			}
		}
		
		// for all Xi, FOLLOW(Xi) dependencies
		for(int i = 0; i < size(); ++i){
			Symbol sym = symbol(i);
			if(sym instanceof NonTerminal){
				Symbol next = null;
				if(i+1 < size())
					next = symbol(i+1);
				
				NonTerminal nt = (NonTerminal)sym;
				for(Production sp : nt.productions()){
					if(!shallowConflicts(sp, i)){
						if(next == null){
							sp._follow_set.addDependency(_follow_set);
						}else{
							if(next instanceof Terminal){
								sp._follow_set.initialValue().add((Terminal)next);
							}else{
								for(Production np : ((NonTerminal)next).productions()){
									if(!shallowConflicts(np, i+1)){
										sp._follow_set.addDependency(np._first_set);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	public void computeSets(){
		_first_set.compute(fs_factory);
		_follow_set.compute(fs_factory);
	}
	
	public void computeSetsComponents(){
		_first_set.component().compute();
		_follow_set.component().compute();
	}
	
	public Terminal firstSet(){
		return _first_set.value();
	}
	
	/**
	 * FOLLOW(this).
	 * <p>
	 * This set is computed by calling the method {@link Syntax#computeFollowSets()} on the corresponding syntax instance.
	 * Before that, the set is empty.
	 * @return FOLLOW(this)
	 */
	public Terminal followSet(){
		return _follow_set.value();
	}
	
	public abstract Label label();
	
	public abstract String constructor();
	
	public abstract String shortString();
	
	public abstract NonTerminal product();
	
	public Symbol left(){
		if(isEmpty())
			return null;
		return symbol(0);
	}
	
	public Symbol right(){
		if(isEmpty())
			return null;
		return symbol(size()-1);
	}
	
	public abstract int size();
	
	public abstract boolean isEmpty();
	
	public abstract boolean isEpsilon();
	
	public abstract Symbol symbol(int position);
	
	public abstract List<Symbol> symbols();
	
	public abstract Set<Attribute> attributes();
	
	public abstract SyntaxProduction syntaxProduction();
	
	public abstract void contextualize(ContextualSymbol cs, Set<ContextualProduction> set) throws UndefinedSymbolException;
	
	public abstract boolean containsTerminal();
	
	public boolean directConflicts(Production p, int pos){
		boolean left_exposed = true;
		boolean right_exposed = true;
		
		for(int i = 0; i < pos; ++i){
			if(!symbol(i).isLayout()){
				left_exposed = false;
				break;
			}
		}
		
		for(int i = pos+1; i < size(); ++i){
			if(!symbol(i).isLayout()){
				right_exposed = false;
				break;
			}
		}
		
		if(left_exposed && p.right() != null && p.right().nonEpsilon())
			left_exposed = false;
		if(right_exposed && p.left() != null && p.left().nonEpsilon())
			right_exposed = false;
		
		if(!left_exposed && !right_exposed)
			return false;
		
		//return syntaxProduction().priorities().shallowConflicts(p.syntaxProduction(), pos);
		for(PriorityLevel l : syntaxProduction().priorities().priorityLevels(pos)){
			if(l.conflicts(p.syntaxProduction()))
				return true;
		}
		return false;
	}
	
	/**
	 * 
	 * @param np A symbol production.
	 * @param pos The position in the production.
	 * @return true if it is not possible to use the production {@code prod} to expend the symbol at position {@code pos}.
	 * Note : this is the old conflicts semantic.
	 */
	public boolean shallowConflicts(Production np, int pos){
		if(ParseTable.current().priorityPolicy() != ParseTable.PriorityPolicy.SHALLOW){
			return directConflicts(np.syntaxProduction(), pos);
		}
		if(pos >= size())
			return false;
		Symbol next = symbol(pos);
		if(np.product().nonContextual().equals(next.nonContextual())){
			//return syntaxProduction().priorities().shallowConflicts(np.syntaxProduction(), pos);
			for(PriorityLevel l : syntaxProduction().priorities().priorityLevels(pos)){
				if(l.conflicts(np.syntaxProduction()))
					return true;
			}
		}
		return false;
	}
	
	@Override
	public int hashCode(){
		if(_hash_code == -1){
			int[] ary = new int[size()];
			for(int i = 0; i < size(); ++i)
				ary[i] = symbol(i).hashCode();
			_hash_code = Utilities.hashCode(ary);
		}
		return _hash_code;
	}
	
	public String graphviz(){
		return shortString();
	}
}

package org.metaborg.sdf2table.grammar;

import java.util.List;
import java.util.Set;

import org.metaborg.sdf2table.core.FixPointMember;
import org.metaborg.sdf2table.parsetable.Label;
import org.metaborg.sdf2table.parsetable.ParseTable;
import org.metaborg.sdf2table.symbol.NonTerminal;
import org.metaborg.sdf2table.symbol.Symbol;
import org.metaborg.sdf2table.symbol.Terminal;
import org.metaborg.sdf2table.symbol.TerminalContainer;

public abstract class Production{
	/**
	 * Production attributes.
	 */
	public enum Attribute{
		ASSOC_LEFT,
		ASSOC_RIGHT,
		
		BRACKET,
		REJECT,
		PREFER,
		
		LONGEST_MATCH
	}
	
	/*static final BooleanFixPointFactory and_factory = new BooleanFixPointFactory(BooleanFixPoint.Operator.AND);
	static final BooleanFixPointFactory or_factory = new BooleanFixPointFactory(BooleanFixPoint.Operator.OR);
	
	FixPointMember<Boolean, BooleanFixPoint> _always_layout = new FixPointMember<>(null);
	FixPointMember<Boolean, BooleanFixPoint> _never_layout = new FixPointMember<>(null);*/
	
	static final FirstSetFactory fs_factory = new FirstSetFactory();
	
	FixPointMember<TerminalContainer, FirstSet> _first_set = new FixPointMember<>(new TerminalContainer());
	
	/**
	 * FOLLOW(this).
	 * <p>
	 * This set is not computed until {@link Syntax#computeFollowSets()} has not been called.
	 */
	//FollowSet _follow_set = new FollowSet(this);
	FixPointMember<TerminalContainer, FirstSet> _follow_set = new FixPointMember<>(new TerminalContainer());
	
	/**
	 * Compute direct dependencies generated by this production.
	 * <p>
	 * For a production P = "A0 A1 ... An -> B", the set of direct dependencies is decided as follow:
	 * 
	 * 1. if P is empty then FIRST(P) depends on FOLLOW(P).
	 * 2. if A0 if a non-terminal then for all production Q that produce A0 and does not conflict P at position 0, FIRST(P) depends on FIRST(Q).
	 * 3. for all Ai of P,
	 * 		if i < n then for all production Q that produce Ai+1 and does not conflict P at position i+1, FOLLOW(Ai) depends on FIRST(Q).
	 * 		if i = n then FOLLOW(Ai) depends on FOLLOW(P).
	 */
	public void computeDependencies(){
		// FIRST(this) dependencies
		if(isEmpty()){
			_first_set.addDependency(_follow_set);
		}else{
			Symbol sym = symbol(0);
			
			if(sym instanceof Terminal){
				_first_set.initialValue().add((Terminal)sym);
			}else{
				for(Production p : ((NonTerminal)sym).productions()){
					if(!shallowConflicts(p, 0))
						_first_set.addDependency(p._first_set);
				}
			}
		}
		
		// for all Xi, FOLLOW(Xi) dependencies
		for(int i = 0; i < size(); ++i){
			Symbol sym = symbol(i);
			if(sym instanceof NonTerminal){
				Symbol next = null;
				if(i+1 < size())
					next = symbol(i+1);
				
				NonTerminal nt = (NonTerminal)sym;
				for(Production sp : nt.productions()){
					if(!shallowConflicts(sp, i)){
						if(next == null){
							sp._follow_set.addDependency(_follow_set);
						}else{
							if(next instanceof Terminal){
								sp._follow_set.initialValue().add((Terminal)next);
							}else{
								for(Production np : ((NonTerminal)next).productions()){
									if(!shallowConflicts(np, i+1)){
										sp._follow_set.addDependency(np._first_set);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	public void computeSets(){
		_first_set.compute(fs_factory);
		_follow_set.compute(fs_factory);
	}
	
	public void computeSetsComponents(){
		_first_set.component().compute();
		_follow_set.component().compute();
	}
	
	public Terminal firstSet(){
		return _first_set.value();
	}
	
	/**
	 * FOLLOW(this).
	 * <p>
	 * This set is computed by calling the method {@link Syntax#computeFollowSets()} on the corresponding syntax instance.
	 * Before that, the set is empty.
	 * @return FOLLOW(this)
	 */
	public Terminal followSet(){
		return _follow_set.value();
	}
	
	public abstract Label label();
	
	public abstract String constructor();
	
	public abstract String shortString();
	
	public abstract NonTerminal product();
	
	public Symbol left(){
		if(isEmpty())
			return null;
		return symbol(0);
	}
	
	public Symbol right(){
		if(isEmpty())
			return null;
		return symbol(size()-1);
	}
	
	public abstract int size();
	
	public abstract boolean isEmpty();
	
	public abstract boolean isEpsilon();
	
	public abstract Symbol symbol(int position);
	
	public abstract List<Symbol> symbols();
	
	public abstract Set<Attribute> attributes();
	
	public abstract SyntaxProduction syntaxProduction();
	
	public abstract boolean containsTerminal();
	
	public boolean directConflicts(Production p, int pos){
		boolean left_exposed = true;
		boolean right_exposed = true;
		
		for(int i = 0; i < pos; ++i){
			if(!symbol(i).isLayout()){
				left_exposed = false;
				break;
			}
		}
		
		for(int i = pos+1; i < size(); ++i){
			if(!symbol(i).isLayout()){
				right_exposed = false;
				break;
			}
		}
		
		if(left_exposed && p.right() != null && p.right().nonEpsilon())
			left_exposed = false;
		if(right_exposed && p.left() != null && p.left().nonEpsilon())
			right_exposed = false;
		
		if(!left_exposed && !right_exposed)
			return false;
		
		return syntaxProduction().priorities().shallowConflicts(p.syntaxProduction(), pos);
	}
	
	/**
	 * 
	 * @param np A symbol production.
	 * @param pos The position in the production.
	 * @return true if it is not possible to use the production {@code prod} to expend the symbol at position {@code pos}.
	 * Note : this is the old conflicts semantic.
	 */
	public boolean shallowConflicts(Production np, int pos){
		if(ParseTable.current().priorityPolicy() != ParseTable.PriorityPolicy.SHALLOW){
			return directConflicts(np.syntaxProduction(), pos);
		}
		if(pos >= size())
			return false;
		Symbol next = symbol(pos);
		if(np.product().nonContextual().equals(next.nonContextual())){
			return syntaxProduction().priorities().shallowConflicts(np.syntaxProduction(), pos);
		}
		return false;
	}
	
	public String graphviz(){
		return shortString();
	}
}

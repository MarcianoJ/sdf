module editor/outline

imports
	include/SDF
	lib/attributes
	lib/editor-common.generated
	lib/outline-library.generated

rules
	
	outline-strategy = custom-label-outline(to-outline-label, to-outline-node)
	
rules
	
	to-outline-label: unparameterized('id) -> 'id
	to-outline-label: parameterized('id, _) -> 'id

	to-outline-label:
		appl -> label
		where
			<?lexical-syntax(_) +
			?context-free-syntax(_) +
			?variables(_) +
			?lexical-variables(_) +
			?lexical-priorities(_) +
			?context-free-priorities(_) +
			?lexical-restrictions(_) +
			?context-free-restrictions(_) + 
			?aliases(_) + 
			?restrictions(_) +
			?syntax(_) +
			?exports(_) +
			?imports(_)> appl;
			label := <appl-to-outline-label> appl
			
	
	appl-to-outline-label:
		appl -> label
		where
			label := <get-constructor; string-replace(|"context-free-", "context-free "); string-replace(|"lexical-", "lexical ")> appl
	
	to-outline-node:
		appl -> result
		where
			<?kernel-start-symbols(_) +
			?lexical-start-symbols(_) +
			?context-free-start-symbols(_)> appl;
			label := <appl-to-outline-label> appl;
			children := <get-arguments; Hd; map(fetch-sort-name; label-to-outline-node)> appl;
			result := Node(label, children)
	
	label-to-outline-node = ?label; !Node(label, [])
	
	to-outline-label:
		p@prod(_, sort, attrs) -> label
		where
			sort-name := <fetch-sort-name> sort;
			if <fetch-cons-name> attrs
			then 
				cons-name := <fetch-cons-name> attrs;
				label := <concat-strings> [sort-name, " {\"", cons-name, "\"}"]
			else label := sort-name
			end
		
	
	fetch-sort-name: sort(s) -> s
	fetch-sort-name: lex(sort(s)) -> <conc-strings> (s, "-LEX")
	fetch-sort-name: cf(sort(s)) -> <conc-strings> (s, "-CF")
	
	
  custom-label-outline(s1, s2) = collect-om(origin-track-forced(s2) <+ to-outline-node(s1, s2), conc)
  
  to-outline-node(s1, s2):
    term -> Node(label, children)
    where
      label := <origin-track-forced(s1)> term;
      children := <get-arguments; custom-label-outline(s1, s2)> term
      
      
      
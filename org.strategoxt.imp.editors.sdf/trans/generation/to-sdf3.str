module generation/to-sdf3
imports
  include/SDF
  lib/sdf3/TemplateLang-pp


overlays
  sdf-cons(x) = term(default(appl(unquoted("cons"), [fun(quoted(x))]))) 

rules
 
 to-sdf3 = 
 	module-to-sdf3 <+ section-to-sdf3 //<+ priority-to-sdf3 <+ prod-to-sdf3
  
  module-to-sdf3:
  		'module(unparameterized(mn), i*, e*) -> Module(Unparameterized(mn), i'*, sections*)
  	with
  		sections* := <filter(section-to-sdf3); try(flatten-list)> e*;
  		i'* := <map(imports-to-sdf)> i*;
  		<reset-counter> "SDF3"  
  		
  module-to-sdf:
  	'module(unparameterized(mn)) -> Module(Unparameterized(mn)) 
  		
  
   imports-to-sdf: 
  	imports(i) -> Imports(i') 
  	with
  		i' := <map(module-to-sdf)> i
  		
  
  /* SDF sections */
  section-to-sdf3:
  	exports(s) -> s'
  	with
  		s' := <section-to-sdf3; try(flatten-list)> s
 
  section-to-sdf3:
  	hiddens(s) -> s'
  	with
  		s' := <section-to-sdf3; try(flatten-list)> s
 
  section-to-sdf3:
  	conc-grammars(g1, g2) -> [g1', g2']
  with
  	g1' := <section-to-sdf3> g1;
  	g2' := <section-to-sdf3> g2 	
  	
  
  //Context-free Start Symbols
  section-to-sdf3: 
  	context-free-start-symbols(symbols) -> SDFSection(ContextFreeStartSymbols(symbols')) 
  	with
  		symbols' := <term-translation> symbols
  		
  		
  //KernelStartSymbols -> kernel-start-symbols
  section-to-sdf3: 
  	kernel-start-symbols(symbols) -> SDFSection(KernelStartSymbols(symbols'))
  	with
  		symbols' := <term-translation> symbols
  		
  //LexicalStartSymbols -> lexical-start-symbols
  section-to-sdf3: 
  	lexical-start-symbols(symbols) -> SDFSection(LexicalStartSymbols(symbols'))
   	with
  		symbols' := <term-translation> symbols
  		
  //productions section
  section-to-sdf3:
   	context-free-syntax(prods*) -> result
   	with
   		prods'* := <filter(prod-to-sdf3); flatten-list> prods*;
   		result  := <not(?[]) < !SDFSection(ContextFreeSyntax(prods'*)) + ![]> prods'*  
   		
   	
   		
   //lexical syntax reductive section
  section-to-sdf3:
   	lexical-syntax(prods*) -> SDFSection(LexicalSyntax(prods'*))
   	with
   		prods'* := <map(prod-to-sdf3); flatten-list> prods* 	
   		
 
 //kernel syntax
  section-to-sdf3:
  	syntax(prods*) -> SDFSection(Kernel(prods'*))
  	with
  		prods'* := <map(prod-to-sdf3); flatten-list> prods*
  		
  		
  //lexical restrictions
  section-to-sdf3:
  	lexical-restrictions(restrictions*) -> SDFSection(LexicalRestrictions(restrictions'*))
  	with
  		restrictions'* := <term-translation> restrictions*
  		
  //context-free restrictions
   section-to-sdf3:
  	context-free-restrictions(restrictions*) -> SDFSection(ContextFreeRestrictions(restrictions'*))
  	with
  		restrictions'* := <term-translation> restrictions*
  
  //kernel restrictions
  section-to-sdf3:
  restrictions(restrictions*) -> SDFSection(Restrictions(restrictions'*))
  	with
  		restrictions'* := <term-translation> restrictions*
  		
  //sorts 
  section-to-sdf3:
  'sorts(symbols*) ->SDFSection(Sorts(symbols'*))
  with
  		symbols'* := <term-translation> symbols*
  		
  
  //aliases
  section-to-sdf3:
  aliases(aliases*) -> SDFSection(Aliases(aliases'*))
  	with
  		aliases'* := <term-translation> aliases*
  
  //variables
  section-to-sdf3:
  	variables(prods*) -> SDFSection(VariablesProductive(prods'*))
  	with
  		prods'* := <map(prod-to-sdf3); flatten-list> prods*
  
    //lexical variables
   section-to-sdf3:
  	lexical-variables(prods*) -> SDFSection(LexVariables(prods'*))
  	with
  		prods'* := <map(prod-to-sdf3); flatten-list> prods*
 
 //context-free priorities
  section-to-sdf3:
  	context-free-priorities(priorities*) -> SDFSection(ContextFreePriorities(priorities'*))
  	with
  		priorities'* := <map(priority-to-sdf3)> priorities*
  
  //lexical priorities
  section-to-sdf3:
  	lexical-priorities(priorities*) -> SDFSection(LexicalPriorities(priorities'*))
  	with
  		priorities'* := <map(priority-to-sdf3)> priorities*
  
  //kernel priorities
  section-to-sdf3:
  	priorities(priorities*) -> SDFSection(Priorities(priorities'*))
  	with
  		priorities'* := <map(priority-to-sdf3)> priorities*
 
  priority-to-sdf3:
  	chain(groups) -> Chain(groups')
  	with
  		groups' := <map(group-to-sdf3 <+ term-translation)> groups
  
  priority-to-sdf3:
  	assoc(gr1, associativity, gr2) -> Assoc(gr1', associativity', gr2')
  	with
  		gr1' := <group-to-sdf3 <+ term-translation> gr1;
  		associativity' := <term-translation> associativity;
  		gr2' := <group-to-sdf3 <+ term-translation> gr2

  group-to-sdf3:
    simple-group(prod) -> SimpleGroup(prod')
    with
    	[prod'] := <prod-to-sdf3; flatten-list> prod
  
  group-to-sdf3:
    prods-group(prods) -> ProdsGroup(prods')
    with
    	prods' := <map(prod-to-sdf3); flatten-list> prods
    
  group-to-sdf3:
    assoc-group(a, prods) -> AssocGroup(a', prods')
    with
    	a' := <term-translation> a;
    	prods' := <map(prod-to-sdf3); flatten-list> prods
 
 
  //Productions
 //regular sdf2 productions that define a sort become sdf3 productions with or without constructors     	
  prod-to-sdf3:
  	prod(symbols*, sort(s), attrs) -> [<term-translation> result, p*]
  	where
  		not(<?[sort("CONTENTCOMPLETE")]> symbols*)
  	with
  		a* := <?attrs(<id>) <+ ![]> attrs;
  		symbols'* := <topdown(try(symbol-to-sdf3))> symbols*;
  		p* := <collect-om(new-prods)> symbols*
  	with   		
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?sdf-cons(_) + ?Constructor(_))> a* ;
  		
  		result := SdfProductionWithCons(SortCons(SortDef(s), c), Rhs(symbols'*), Attrs(a'*))
  	<+  result := SdfProduction(SortDef(s), Rhs(symbols'*), Attrs(a*)) 
  
  
  //Lexical kernel sdf2 productions that define a sort become sdf3 productions with or without constructors     	
  prod-to-sdf3:
  	prod(symbols*, lex(sort(s)), attrs) -> [<term-translation> result, p*]
  	with
  		a* := <?attrs(<id>) <+ ![]> attrs;
  		symbols'* := <topdown(try(symbol-to-sdf3))> symbols*;
  		p* := <collect-om(new-prods)> symbols*
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?sdf-cons(_) + ?Constructor(_))> a* ;
  		result := SdfProductionWithCons(SortCons(Lex(SortDef(s)), c), Rhs(symbols'*), Attrs(a'*))
  	<+  result := SdfProduction(Lex(SortDef(s)), Rhs(symbols'*), Attrs(a*)) 
  
  //Cf kernel sdf2 productions that define a sort become sdf3 productions with or without constructors     	
  prod-to-sdf3:
  	prod(symbols*, cf(sort(s)), attrs) -> [<term-translation> result, p*]
  	with
  		a* := <?attrs(<id>) <+ ![]> attrs;
  		symbols'* := <map(symbol-to-sdf3)> symbols*;
  		p* := <collect-om(new-prods)> symbols*
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?sdf-cons(_) + ?Constructor(_))> a* ;
  		result := SdfProductionWithCons(SortCons(Cf(SortDef(s)), c), Rhs(symbols'*), Attrs(a'*))
  	<+  result := SdfProduction(Cf(SortDef(s)), Rhs(symbols'*), Attrs(a*)) 
  
  
  //regular sdf2 productions with complex symbols on the lhs become sdf3 productions with or without constructors     	
  prod-to-sdf3:
  	prod(symbols*, symbol, attrs) -> [<term-translation> result, p*]
  	where
  		not(<?sort(s) + ?cf(sort(s)) + ?lex(sort(s))> symbol)
  	with
  		a* := <?attrs(<id>) <+ ![]> attrs;
  		symbols'* := <topdown(try(symbol-to-sdf3))> symbols*;
  		symbol' := <symbol-to-sdf3> symbol;
  		p* := <collect-om(new-prods)> symbols*		
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?sdf-cons(_) + ?Constructor(_))> a* ;
  		result := SdfProductionWithCons(SortCons(symbol', c), Rhs(symbols'*), Attrs(a'*))
  	<+  result := SdfProduction(symbol', Rhs(symbols'*), Attrs(a*)) 
  
  
  
 
  
  
   symbol-to-sdf3:
   	symbol -> symbol'
   	where
   		not(is-unsupported) 	
   	with
   		symbol' := <try(terms-to-sdf <+ special-term-to-sdf <+ term-to-sdf )> symbol
   	
  symbol-to-sdf3:
   	symbol -> symbol'
   	where
   		is-unsupported
   	with
   		symbol' := <lift-symbol> symbol
  
  lift-symbol:
  	alt(s1, s2) -> newsymbol
  	with
  		newsymbol := Sort($[Alt[<next-counter> "SDF3"]])
  
  lift-symbol:
  	empty() -> newsymbol
  	with
  		newsymbol := Sort($[Empty]) 
  		
  lift-symbol:
  	seq(head, tail*) -> newsymbol
  	with
  		newsymbol := Sort($[Seq[<next-counter> "SDF3"]])
 
  lift-symbol:
  	tuple(head, rest*) -> newsymbol
  	with
  		newsymbol := Sort($[Tup[<next-counter> "SDF3"]])
  		
  lift-symbol:
  	func(args*, result) -> newsymbol
  	with
  		newsymbol := Sort($[Func[<next-counter> "SDF3"]])
  		
  lift-symbol:
  	strategy(sleft, sright) -> newsymbol
  	with
  		newsymbol := Sort($[Strategy[<next-counter> "SDF3"]])		
  		
  new-prods:
  	alt(s1, s2) -> [<prod-to-sdf3> prod([s1], sort($[Alt[<get-counter> "SDF3"]]), no-attrs()), <prod-to-sdf3> prod([s2], sort($[Alt[<get-counter> "SDF3"]]), no-attrs())] 	
  
  new-prods:
  	empty() -> <prod-to-sdf3> prod([], sort("Empty"), no-attrs())
  	
  new-prods:
  	seq(head, tail*) -> <prod-to-sdf3> prod([head, tail*], sort($[Seq[<get-counter> "SDF3"]]), attrs([sdf-cons("\"Seq\"")]))	
  	
  new-prods:
  	tuple(head, rest*) -> <prod-to-sdf3> prod([lit("\"<\""), tuple*, lit("\">\"")], sort($[Tup[<get-counter> "SDF3"]]), attrs([sdf-cons("\"Tuple\"")]))
  with
  	tuple* := <separate-by(|lit("\",\""))> [head, rest*]
  	
  new-prods:
  	func(args*, result) -> <prod-to-sdf3> prod([args*, lit("\"=>\""), result], sort($[Func[<get-counter> "SDF3"]]), attrs([sdf-cons("\"Func\"")]))	
  
  new-prods:
  	strategy(sleft, sright) -> <prod-to-sdf3> prod([sleft, lit("\"->\""), sright], sort($[Strategy[<get-counter> "SDF3"]]), attrs([sdf-cons("\"Strategy\"")]))
  
 rules //conversion of SDF3 terms into SDF2
	
  term-translation = topdown(try(terms-to-sdf <+ special-term-to-sdf <+ term-to-sdf ))
	
	//regular constructor conversion
  term-to-sdf:
  	cons#(args) -> cons'#(args)
  	with
  		[f|fs] := <explode-string> cons;
  		cons' := <implode-string> [<to-upper> f|fs]
  		
  //special constructors conversion		
  special-term-to-sdf:
  	iter-sep(sort, lit) -> IterSep(sort, lit) 
  	
  // special-term-to-sdf:
  // 	Right() -> right()
  
  special-term-to-sdf:
  	iter-star(sort) -> IterStar(sort)
  	
  special-term-to-sdf:
  	simple-charclass(sort) -> Simple(sort) 
  	
  special-term-to-sdf:
  	char-class(sort) -> CharClass(sort) 
  	
  special-term-to-sdf:
  	label_start() -> LabelStart()
  	
  special-term-to-sdf:
  	empty-grammar() -> Empty()
  
  special-term-to-sdf:
  	unquoted-fun(s) -> UnquotedFun(s)
  
  special-term-to-sdf:
  	quoted-fun(s) -> QuotedFun(s)
  
  special-term-to-sdf:
  	prefix-fun(fn, syms, sym, att) -> PrefixFun(fn, syms, sym, att) 
  
  special-term-to-sdf:
  	non-assoc() -> NonAssoc()
  	
  special-term-to-sdf:
  	with-arguments(g, a) -> WithArguments(g, a)
  
  special-term-to-sdf:
  	non-transitive(g) -> NonTransitive(g) 
  
  special-term-to-sdf:
  	simple-group(p) -> SimpleGroup(p)
  		
  special-term-to-sdf:
  	prods-group(p) -> ProdsGroup(p)
        
  special-term-to-sdf:
  	assoc-group(a, p) -> AssocGroup(a, p)
  
  special-term-to-sdf:
  	real-con(i, n, o) -> RealCon(i, n, o)
  
  special-term-to-sdf:
  	iter-star-sep(sort, sep)	-> IterStarSep(sort, sep)
  
  special-term-to-sdf:
  	 file-start() -> FileStart()
  	
  special-term-to-sdf:
  	 parameterized-sort(sort, sym) -> ParameterizedSort(sort, sym)
  		     
  special-term-to-sdf:
  	ci-lit(lit) -> CiLit(lit)
  
  special-term-to-sdf:
  	no-attrs() -> NoAttrs()
  
  special-term-to-sdf:
  	attrs([]) -> NoAttrs()
  	
  special-term-to-sdf:
  	Attrs([]) -> NoAttrs()
  	
  
  special-term-to-sdf:
  	term(default(fun(unquoted("deprecated")))) -> Deprecated() 
  	
  special-term-to-sdf:
  	term(default(appl(unquoted("deprecated"), [fun(quoted(s))]))) -> Deprecated(s)	
 
 
 //unsupported symbols in SDF3
	unsupported-symbol:
		<is-unsupported> -> <fail>
	with
		debug(!"Unsupported symbol ")	
 
 
 	
  		  		
  terms-to-sdf:
  	[term | tail] -> <id>
  		
  terms-to-sdf:
  	[] -> []
  		
 lift-constr:
  	Constructor(c) -> Constructor(<un-double-quote; try(to-first-upper)> c)
  	
 lift-constr: 		
 	sdf-cons(c) ->  Constructor(<un-double-quote; try(to-first-upper)> c)
 	
 to-first-upper:
 	name -> name'
 where
 	[f|fs] := <explode-string> name;
  	name' := <implode-string> [<to-upper> f|fs]	
  	
 is-unsupported = ?alt(_, _) + ?empty() + ?seq(_,_) + ?tuple(_,_) + ?func(_,_) + ?strategy(_,_)	+ 
 				   ?Alt(_, _) + ?Empty() + ?Seq(_,_)

module generation/to-sdf3
imports
  include/SDF
  lib/sdf3/TemplateLang-pp


overlays
  sdf-cons(x) = term(default(appl(unquoted("cons"), [fun(quoted(x))]))) 

rules
 
 to-sdf3 = 
 	module-to-sdf3 <+ section-to-sdf3 //<+ priority-to-sdf3 <+ prod-to-sdf3
  
  module-to-sdf3:
  		'module(unparameterized(mn), i*, e*) -> Module(Unparameterized(mn), i'*, sections*)
  	with
  		sections* := <filter(section-to-sdf3); try(flatten-list)> e*;
  		i'* := <map(imports-to-sdf)> i*
  		
  module-to-sdf:
  	'module(unparameterized(mn)) -> Module(Unparameterized(mn)) 
  		
  
   imports-to-sdf: 
  	imports(i) -> Imports(i') 
  	with
  		i' := <map(module-to-sdf)> i
  		
  
  /* SDF sections */
  section-to-sdf3:
  	exports(s) -> s'
  	with
  		s' := <section-to-sdf3; try(flatten-list)> s
 
  section-to-sdf3:
  	conc-grammars(g1, g2) -> [g1', g2']
  with
  	g1' := <section-to-sdf3> g1;
  	g2' := <section-to-sdf3> g2 	
  	
  
  //Context-free Start Symbols
  section-to-sdf3: 
  	context-free-start-symbols(symbols) -> SDFSection(ContextFreeStartSymbols(symbols')) 
  	with
  		symbols' := <term-translation> symbols
  		
  		
  //KernelStartSymbols -> kernel-start-symbols
  section-to-sdf3: 
  	kernel-start-symbols(symbols) -> SDFSection(KernelStartSymbols(symbols'))
  	with
  		symbols' := <term-translation> symbols
  		
  //LexicalStartSymbols -> lexical-start-symbols
  section-to-sdf3: 
  	lexical-start-symbols(symbols) -> SDFSection(LexicalStartSymbols(symbols'))
  	with
  		symbols' := <term-translation> symbols
  		
  //productions section
  section-to-sdf3:
   	context-free-syntax(prods*) -> SDFSection(ContextFreeSyntax(prods'*)) 
   	with
   		prods'* := <map(prod-to-sdf3)> prods*
   		
   //lexical syntax reductive section
  section-to-sdf3:
   	lexical-syntax(prods*) -> SDFSection(LexicalSyntax(prods'*))
   	with
   		prods'* := <map(prod-to-sdf3)> prods* 				
 
 //kernel syntax
  section-to-sdf3:
  	syntax(prods*) -> SDFSection(Kernel(prods'*))
  	with
  		prods'* := <map(prod-to-sdf3)> prods*
  		
  //lexical restrictions
  section-to-sdf3:
  	lexical-restrictions(restrictions*) -> SDFSection(LexicalRestrictions(restrictions'*))
  	with
  		restrictions'* := <term-translation> restrictions*
  		
  //context-free restrictions
   section-to-sdf3:
  	context-free-restrictions(restrictions*) -> SDFSection(ContextFreeRestrictions(restrictions'*))
  	with
  		restrictions'* := <term-translation> restrictions*
  
  //kernel restrictions
  section-to-sdf3:
  restrictions(restrictions*) -> SDFSection(Restrictions(restrictions'*))
  	with
  		restrictions'* := <term-translation> restrictions*
  		
  //sorts 
  section-to-sdf3:
  'sorts(symbols*) ->SDFSection(Sorts(symbols'*))
  	with
  		symbols'* := <term-translation> symbols*
  
  //aliases
  section-to-sdf3:
  aliases(aliases*) -> SDFSection(Aliases(aliases'*))
  	with
  		aliases'* := <term-translation> aliases*
  
  //variables
  section-to-sdf3:
  	variables(prods*) -> SDFSection(Variables(prods'*))
  	with
  		prods'* := <map(prod-to-sdf3)> prods*
  
    //lexical variables
   section-to-sdf3:
  	lexical-variables(prods*) -> SDFSection(LexVariables(prods'*))
  	with
  		prods'* := <map(prod-to-sdf3)> prods*
 
 //context-free priorities
  section-to-sdf3:
  	context-free-priorities(priorities*) -> SDFSection(ContextFreePriorities(priorities'*))
  	with
  		priorities'* := <map(priority-to-sdf3)> priorities*
  
  //lexical priorities
  section-to-sdf3:
  	lexical-priorities(priorities*) -> SDFSection(LexicalPriorities(priorities'*))
  	with
  		priorities'* := <map(priority-to-sdf3)> priorities*
  
  //kernel priorities
  section-to-sdf3:
  	priorities(priorities*) -> SDFSection(Priorities(priorities'*))
  	with
  		priorities'* := <map(priority-to-sdf3)> priorities*
 
  priority-to-sdf3:
  	chain(groups) -> Chain(groups')
  	with
  		groups' := <map(group-to-sdf3 <+ term-translation)> groups
  
  priority-to-sdf3:
  	assoc(gr1, associativity, gr2) -> Assoc(gr1', associativity', gr2')
  	with
  		gr1' := <group-to-sdf3 <+ term-translation> gr1;
  		associativity' := <term-translation> associativity;
  		gr2' := <group-to-sdf3 <+ term-translation> gr2

  group-to-sdf3:
    simple-group(prod) -> SimpleGroup(prod')
    with
    	prod' := <priority-prod-to-sdf3> prod
  
  group-to-sdf3:
    ProdsGroup(prods) -> prods-group(prods')
    with
    	prods' := <map(priority-prod-to-sdf3)> prods
    
  group-to-sdf3:
    AssocGroup(a, prods) -> assoc-group(a', prods')
    with
    	a' := <term-translation> a;
    	prods' := <map(priority-prod-to-sdf3)> prods
 
 /* FIXME : How to deal with priorities, generating Sort.Cons sdf3 priorities? */
  priority-prod-to-sdf3 = term-translation
  
  //Productions
 //regular sdf2 productions that define a sort become sdf3 productions with or without constructors     	
  prod-to-sdf3:
  	prod(symbols*, sort(s), attrs) -> <term-translation> result
  	with
  		a* := <?attrs(<id>) <+ ![]> attrs;
  		symbols'* := <map(symbol-to-sdf3)> symbols*
  	with   		
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?sdf-cons(_) + ?Constructor(_))> a* ;
  		
  		result := SdfProductionWithCons(SortCons(SortDef(s), c), Rhs(symbols'*), Attrs(a'*))
  	<+  result := SdfProduction(SortDef(s), Rhs(symbols'*), Attrs(a*)) 
  
  
  //Lexical kernel sdf2 productions that define a sort become sdf3 productions with or without constructors     	
  prod-to-sdf3:
  	prod(symbols*, lex(sort(s)), attrs) -> <term-translation> result
  	with
  		a* := <?attrs(<id>) <+ ![]> attrs;
  		symbols'* := <map(symbol-to-sdf3)> symbols*
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?sdf-cons(_) + ?Constructor(_))> a* ;
  		result := SdfProductionWithCons(SortCons(Lex(SortDef(s)), c), Rhs(symbols'*), Attrs(a'*))
  	<+  result := SdfProduction(Lex(SortDef(s)), Rhs(symbols'*), Attrs(a*)) 
  
  //Cf kernel sdf2 productions that define a sort become sdf3 productions with or without constructors     	
  prod-to-sdf3:
  	prod(symbols*, cf(sort(s)), attrs) -> <term-translation> result
  	with
  		a* := <?attrs(<id>) <+ ![]> attrs;
  		symbols'* := <map(symbol-to-sdf3)> symbols*
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?sdf-cons(_) + ?Constructor(_))> a* ;
  		result := SdfProductionWithCons(SortCons(Cf(SortDef(s)), c), Rhs(symbols'*), Attrs(a'*))
  	<+  result := SdfProduction(Cf(SortDef(s)), Rhs(symbols'*), Attrs(a*)) 
  
  
  //regular sdf2 productions with complex symbols on the lhs become sdf3 productions with or without constructors     	
  prod-to-sdf3:
  	prod(symbols*, symbol, attrs) -> <term-translation> result
  	where
  		not(<?sort(s) + ?cf(sort(s)) + ?lex(sort(s))> symbol)
  	with
  		a* := <?attrs(<id>) <+ ![]> attrs;
  		symbols'* := <map(symbol-to-sdf3)> symbols*;
  		symbol' := <symbol-to-sdf3> symbol  		
  	with 
  		c := <getfirst(lift-constr)> a*;
  		a'* := <remove-all(?sdf-cons(_) + ?Constructor(_))> a* ;
  		result := SdfProductionWithCons(SortCons(symbol', c), Rhs(symbols'*), Attrs(a'*))
  	<+  result := SdfProduction(symbol', Rhs(symbols'*), Attrs(a*)) 
  
  
  symbol-to-sdf3:
   	symbol -> symbol'
   	with
   		symbol' := <unsupported-symbol <+ term-translation> symbol
   	
  
  
 rules //conversion of SDF3 terms into SDF2
	
  term-translation = topdown(try(terms-to-sdf <+ special-term-to-sdf <+ term-to-sdf ))
	
	//regular constructor conversion
  term-to-sdf:
  	cons#(args) -> cons'#(args)
  	with
  		[f|fs] := <explode-string> cons;
  		cons' := <implode-string> [<to-upper> f|fs]
  		
  //special constructors conversion		
  special-term-to-sdf:
  	iter-sep(sort, lit) -> IterSep(sort, lit) 
  	
  // special-term-to-sdf:
  // 	Right() -> right()
  
  special-term-to-sdf:
  	iter-star(sort) -> IterStar(sort)
  	
  special-term-to-sdf:
  	simple-charclass(sort) -> Simple(sort) 
  	
  special-term-to-sdf:
  	char-class(sort) -> CharClass(sort) 
  	
  special-term-to-sdf:
  	label_start() -> LabelStart()
  	
  special-term-to-sdf:
  	empty-grammar() -> Empty()
  
  special-term-to-sdf:
  	unquoted-fun(s) -> UnquotedFun(s)
  
  special-term-to-sdf:
  	quoted-fun(s) -> QuotedFun(s)
  
  special-term-to-sdf:
  	prefix-fun(fn, syms, sym, att) -> PrefixFun(fn, syms, sym, att) 
  
  special-term-to-sdf:
  	non-assoc() -> NonAssoc()
  	
  special-term-to-sdf:
  	with-arguments(g, a) -> WithArguments(g, a)
  
  special-term-to-sdf:
  	non-transitive(g) -> NonTransitive(g) 
  
  special-term-to-sdf:
  	simple-group(p) -> SimpleGroup(p)
  		
  special-term-to-sdf:
  	prods-group(p) -> ProdsGroup(p)
        
  special-term-to-sdf:
  	assoc-group(a, p) -> AssocGroup(a, p)
  
  special-term-to-sdf:
  	real-con(i, n, o) -> RealCon(i, n, o)
  
  special-term-to-sdf:
  	iter-star-sep(sort, sep)	-> IterStarSep(sort, sep)
  
  special-term-to-sdf:
  	 file-start() -> FileStart()
  	
  special-term-to-sdf:
  	 parameterized-sort(sort, sym) -> ParameterizedSort(sort, sym)
  		     
  special-term-to-sdf:
  	ci-lit(lit) -> CiLit(lit)
  
  special-term-to-sdf:
  	no-attrs() -> NoAttrs()
  
  special-term-to-sdf:
  	attrs([]) -> NoAttrs()
  	
  special-term-to-sdf:
  	Attrs([]) -> NoAttrs()
  	
  
  special-term-to-sdf:
  	term(default(fun(unquoted("deprecated")))) -> Deprecated() 
  	
  special-term-to-sdf:
  	term(default(appl(unquoted("deprecated"), [fun(quoted(s))]))) -> Deprecated(s)	
 
 
 //unsupported symbols in SDF3
	unsupported-symbol:
		<is-unsupported> -> <fail>
	with
		debug(!"Unsupported symbol ")	
 
 	
  		  		
  terms-to-sdf:
  	[term | tail] -> <id>
  		
  terms-to-sdf:
  	[] -> []
  		
 lift-constr:
  	Constructor(c) -> Constructor(<un-double-quote; try(to-first-upper)> c)
  	
 lift-constr: 		
 	sdf-cons(c) ->  Constructor(<un-double-quote; try(to-first-upper)> c)
 	
 to-first-upper:
 	name -> name'
 where
 	[f|fs] := <explode-string> name;
  	name' := <implode-string> [<to-upper> f|fs]	
  	
 is-unsupported = ?alt(_, _) + ?empty() + ?seq(_,_) + ?tuple(_,_) + ?func(_,_) + ?strategy(_,_)	
/*  		
  
  		
  
  //TemplateSection
  section-to-sdf(|chars, newline, kfr):
  	TemplateSection(x) -> [context-free-syntax(p*), inj*, restr*]
  	with
  		p* := <map(prod-to-sdf(|chars, newline))> x;
  		//content complete prods
  		cc* := < map(?TemplateProduction(SortDef(<id>), _, _) <+ ?TemplateProductionWithCons(SortCons(SortDef(<id>), Constructor(_)), _, _))
             ; nub 
             ; map(sort-to-contentcomplete)> x;	
        if [] := cc*
        then
        	inj* := []
        else
          inj* := [context-free-syntax(<term-translation> cc*)]
        end;
  		// lexical restrictions
  		let
	  		chars-end-with-identifier-char =
	            where(reverse; ?[<is-alphanum + '_'> | _])
	
	          string-ends-with-identifier-char =
	            where(explode-string; chars-end-with-identifier-char)
  		in
  			r* := <collect-om(?String(<string-ends-with-identifier-char>));
               filter(string-to-sdf(|chars); last)> x;
	        if !r* => [] + !kfr => None() then
	          restr* := []
	        else
	          restr* := [lexical-restrictions([follow(r*, kfr)])] 
	        end
  		end
  
  prod-to-sdf(|chars, newline):
  	TemplateProduction(s, t, a) -> prod(t', s', a')
  	with
  		t' := <template-to-sdf(|chars, newline)> t;
  		s' := <term-translation> s;
  		a' := <term-translation> a		
  		
  		
  prod-to-sdf(|chars, newline):
  	TemplateProductionWithCons(SortCons(s, Constructor(cons)), t, Attrs(a*)) -> prod(t', s', a''*)
  	with
  		t' := <template-to-sdf(|chars, newline)> t;
  		s' := <term-translation> s;
  		c   := <double-quote> cons; 
        a'* := [sdf-cons(c) , a*];
  		a''* := <term-translation> Attrs(a'*)	
  
  //single-line template
  template-to-sdf(|chars, newline):
  	SingleLineTemplate(elems) -> elems'
  	with
  	elems' := <filter(template-elem-to-sdf(|chars))> elems
  	
  template-elem-to-sdf(|chars):
  	String(t) -> <string-to-sdf(|chars)> t
  	
  template-elem-to-sdf(|chars):
  	Placeholder(symbol, option) -> symbol' 
  	where
  		<?IterSep(_, Lit(lit)) + ?IterStarSep(_, Lit(lit)) + ?Label(_, IterSep(_, Lit(lit))) + ?Label(_, IterStarSep(_, Lit(lit)))> symbol
  	with
  		lit' := <separator-to-literal> lit;
  		//debug(!"lit' = ");
  		if "" := lit'
  		then
  			switch !symbol
	  			case ?IterSep(sym, _) : symbol' := <term-translation> Iter(sym)
	  			case ?IterStarSep(sym, _) : symbol' := <term-translation> IterStar(sym)
	  			case ?Label(l, IterSep(sym, _)) : symbol' := <term-translation> Label(l, Iter(sym))
	  			case ?Label(l, IterStarSep(sym, _)) : symbol' := <term-translation> Label(l, IterStar(sym))
  			end
  		else	
	  		switch !symbol
	  			case ?IterSep(sym, _) : symbol' := <term-translation> IterSep(sym, Lit(lit'))
	  			case ?IterStarSep(sym, _) : symbol' := <term-translation> IterStarSep(sym, Lit(lit'))
	  			case ?Label(l, IterSep(sym, _)) : symbol' := <term-translation> Label(l, IterSep(sym, Lit(lit')))
	  			case ?Label(l, IterStarSep(sym, _)) : symbol' := <term-translation> Label(l, IterStarSep(sym, Lit(lit')))
	  		end
	  	end	
  		
  template-elem-to-sdf(|chars):
  	Placeholder(symbol, option) -> <term-translation> symbol
  	where
  		<not(?IterSep(_, Lit(lit)) + ?IterStarSep(_, Lit(lit)) + ?Label(_, IterSep(_, Lit(lit))) + ?Label(_, IterStarSep(_, Lit(lit))))> symbol
  
  	
  // template-elem-to-sdf(|chars):
  // 	Placeholder(None(), Sort(x), regular, option) -> result
  // 	where <not(one(Separator(not(string-is-layout))))> option
  // 	with
  // 		switch !(regular)
  // 		case ?(Star()) : result := iter-star(sort(x))
  // 		case ?(Option()) : result := opt(sort(x))
  // 		case ?(Plus()) : result := iter(sort(x))
  // 		case ?(None()) : result := sort(x)
  // 		end
  // 		
  // template-elem-to-sdf(|chars):
  // 	Placeholder(None(), Sort(x), regular, option) -> result
  // 	where <one(Separator(not(string-is-layout)))> option
  // 	with
  // 		switch !(regular)
  // 		case ?(Star()) : result := iter-star-sep(sort(x), lit(<separator-to-literal> option))
  // 		case ?(Plus()) : result := iter-sep(sort(x), lit(<separator-to-literal> option))
  // 		end
  // 	
  // 	
  // template-elem-to-sdf(|chars):
  // 	Placeholder(Label(Unquoted(l)), Sort(x), regular, option) -> label(unquoted(l), result)	
  // 	where <not(one(Separator(not(string-is-layout))))> option
  // 	with
  // 		switch !(regular)
  // 		case ?(Star()) : result := iter-star(sort(x))
  // 		case ?(Option()) : result := opt(sort(x))
  // 		case ?(Plus()) : result := iter(sort(x))
  // 		case ?(None()) : result := sort(x)  		
  // 		end
  // 
  // template-elem-to-sdf(|chars):
  // 	Placeholder(Label(Unquoted(l)), Sort(x), regular, option) -> label(unquoted(l), result)	
  // 	where <one(Separator(not(string-is-layout)))> option
  // 	with
  // 		switch !(regular)
  // 		case ?(Star()) : result := iter-star-sep(sort(x), lit(<separator-to-literal> option))
  // 		case ?(Plus()) : result := iter-sep(sort(x), lit(<separator-to-literal> option)) 		
  // 		end
  
  //multi-line template
  template-to-sdf(|chars, newline):
     Template(lines) -> elems
     with
     	elems := <map(line-to-sdf(|chars))> lines
     
 
  add-newline-first: 
 	Line(elem*) -> Line([String("\n") | elem*])
  	
  add-newline-last : 
  	Line(elem*) -> Line([elem*, String("\n")])
 
  line-to-sdf(|chars):
  	Line(elems) -> elems'
  	with
  		elems' := <filter(template-elem-to-sdf(|chars))> elems
  




 char-is-layout =
    ' ' + '\t' + '\r' + '\n'

  string-is-layout =
    string-as-chars(all(char-is-layout))

  remove-layout =
    string-as-chars(filter(not(char-is-layout)))

  separator-to-literal = un-double-quote; unescape; remove-layout; template-escape


   // * Split on the edges delimiting identifiers.
   // * E.g. "func(x,y)" => ["func", "(", "x", ",", "y", ")"]
   
  string-to-sdf(|chars) =
    string-edge-tokenize(where({x: ?x; <one(?x)> chars}));
    //debug(!"stringtosdf");
    // FIXME: Case insensitive literals need ci-lit/single-quote.
    map(!lit(<template-escape; double-quote>))
    
  
 sort-to-contentcomplete:
     s -> prod([sort("CONTENTCOMPLETE")], sort(s), attrs([sdf-cons(c)]))
     with
     	c := <double-quote> $[COMPLETION-[s]]

template-escape =
    string-replace(|"\\", "\\\\");
    string-replace(|"\t", "\\t");
    string-replace(|"\r", "\\r");
    string-replace(|"\n", "\\n");
    //string-replace(|"'", "\\'");
    string-replace(|"\"", "\\\"")
*/
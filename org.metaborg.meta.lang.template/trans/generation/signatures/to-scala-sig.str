module generation/signatures/to-scala-sig

imports
  libstratego-lib
  libstrc
  analysis/types
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  generation/gen-utils/to-str
  analysis/desugar

imports
  signatures/aliases/-
  signatures/aterms/-
  signatures/basic/-
  signatures/characterclass/-
  signatures/constants/-
  signatures/grammar/-
  signatures/kernel/-
  signatures/labels/-
  signatures/layout/-
  signatures/layout-constraints/-
  signatures/lifting/-
  signatures/literals/-
  signatures/modules/-
  signatures/priority/-
  signatures/regular/-
  signatures/renaming/-
  signatures/restrictions/-
  signatures/sdf2-core/-
  signatures/sorts/-
  signatures/symbols/-
  signatures/TemplateLang-sig

imports
  generation/signatures/to-sig
  libspoofax/core/language

rules

  module-to-scala-sig-string: input -> ret
  with if language-specification;debug(|"lang-spec: ") => (_, grpId, ident, _, _) then
    // (name, groupId, id, version, location)
    ret := <module-to-scala-sig-string(|[grpId, ident, "ast"])> input
  else
    ret := <module-to-scala-sig-string(|["org.example", "ExampleLang", "ast"])> input
  end

  module-to-scala-sig-string(|pkg-base*): Module(Unparameterized(m), i*, s*) ->
$[package [pkg]

object [m] {
  // Generic imports
  import org.metaborg.scalaTerms
  import org.metaborg.scalaTerms.{ sdf, STerm }
  // Generated imports
  [imports]
  // Lexical definitions
  [lexical-definitions]
  // Lexical extractors
  [lexical-companions]
  // Sort definitions
  [sort-definitions]
  // Constructor definitions
  [constructor-definitions]
  // Extractors from STerm
  [sort-companions]
}]
  with pkg := <module-to-scala-package-name(|pkg-base*)> Module(Unparameterized(m))
     ; imports := <map(to-scala-import(|pkg-base*)); string-list-join(|"\n")> i*
     ; lexical-sorts := <lexical-sorts> s*
     ; lexical-definitions := <lexicals-to-scala-sig(|pkg-base*)> lexical-sorts
     ; lexical-companions := <lexical-matching-in-scala> lexical-sorts
     
     ; sort* := <unique-context-free-sections(context-free-sort)> s*
     ; injection* := <unique-context-free-sections(context-free-injection)> s*
     ; constructor* := <unique-context-free-sections(context-free-constructor)> s*
     
     ; sort-definitions := <sorts-to-scala-sig> (sort*, injection*)
     ; constructor-definitions := <constructors-to-scala-sig> (sort*, constructor*)
     ; sort-companions := <sort-matching-in-scala> (sort*, injection*, constructor*)

  to-scala-import(|pkg-base*): Imports(i*) ->
    <map(module-to-scala-import-name(|pkg-base*); !$[import [<id>]]);string-list-join(|"\n")> i*

  module-to-scala-package-name(|pkg-base*):
    Module(Unparameterized(m)) -> <separate-by(|".");concat-strings> [pkg-base*, modulepart*]
  with modulepart* := <string-as-chars(remove-all(?'-'))
                      ;string-tokenize(|['/']); init> m

  module-to-scala-import-name(|pkg-base*):
    Module(Unparameterized(m)) -> <separate-by(|".");concat-strings> [pkg-base*, modulepart*, "_"]
  with modulepart* := <string-as-chars(remove-all(?'-'))
                      ;string-tokenize(|['/'])> m

  lexicals-to-scala-sig(|pkg-base*) =
    map(lexsort-to-scala-decl(|pkg-base*))
  ; string-list-join(|"\n")

  lexical-sorts =
      filter(lexical-section-sorts + kernel-section-lexical-sort)
    ; concat
    ; nub

  lexical-section-sorts = ?SDFSection(LexicalSyntax(<filter(get-sort-from-prod)>))
  kernel-section-lexical-sort = ?SDFSection(Kernel(<filter(get-lex-kernel-sort-from-prod)>))

  get-lex-kernel-sort-from-prod:
    <?SdfProduction(Lex(SortDef(s)), _, Attrs(a*))
    +?SdfProductionWithCons(SortCons(Lex(SortDef(s)), _), _, Attrs(a*))> -> s
  where <not(fetch-elem(?Reject()))> a*

  lexical-matching-in-scala = map(lexsort-to-companion-object); string-list-join(|"\n")

  sorts-to-scala-sig = sorts-to-scala-decls; string-list-join(|"\n")

  constructors-to-scala-sig: (sort*, constructor*) -> result
  with cons-by-sort := <map(\sort -> <match-sort-and-cons(|sort)> constructor*\)> sort*
     ; result := <map(sort-cons-to-scala-decl); string-list-join(|"\n")> cons-by-sort

  match-sort-and-cons(|sort): constructor* ->
    (sort, <retain-all(?(_,FunType(_, ConstType(SortNoArgs(sort)))))> constructor*)

  unique-context-free-sections(s) = filter(context-free-sections(s)); concat; nub

  context-free-sections(s) =
    ?SDFSection(ContextFreeSyntax(<filter(s)>)) + ?SDFSection(Kernel(<filter(s)>))
  + ?TemplateSection(<filter(s)>)

  // TODO: get RHS and support `Label(lbl, sort)` instead of using get-type
  context-free-constructor:
    SdfProductionWithCons(SortCons(sd,Constructor(c)), _, Attrs(a*)) ->
      (<strip-annos> c, <get-type> c)
  where <?SortDef(s) + ?Cf(SortDef(s))> sd
      ; <not(fetch-elem(?Reject() + ?Bracket()))> a*

  context-free-constructor:
    TemplateProductionWithCons(SortCons(SortDef(s), Constructor(c)), _, Attrs(a*)) ->
      (<strip-annos> c, <get-type> c)
  where <not(fetch-elem(?Reject() + ?Bracket()))> a*

  context-free-injection:
    SdfProduction(sd, rhs, Attrs(a*)) -> (s, sort)
  where <?SortDef(s) + ?Cf(SortDef(s))> sd
      ; <not(fetch-elem(?Reject() + ?Bracket()))> a*
      ; (  (ConstType(SortNoArgs(sort)) := <get-type; Hd> rhs)
        <+ (<debug(|"[to-scala-sig] bad injection rule rhs: ")> rhs; fail) )

  context-free-injection:
    TemplateProduction(SortDef(s), t, Attrs(a*)) -> (s, sort)
  where <not(fetch-elem(?Reject() + ?Bracket()))> a*
      ; (  (ConstType(SortNoArgs(sort)) := <get-type; Hd> t)
        <+ (<debug(|"[to-scala-sig] bad injection rule rhs: ")> t; fail) )

  context-free-sort:
    SdfProductionWithCons(SortCons(sd,_), _, Attrs(a*)) -> s
  where <?SortDef(s) + ?Cf(SortDef(s))> sd
      ; <not(fetch-elem(?Reject() + ?Bracket()))> a*

  context-free-sort:
    TemplateProductionWithCons(SortCons(SortDef(s), _), _, Attrs(a*)) -> s
  where <not(fetch-elem(?Reject() + ?Bracket()))> a*

  context-free-sort:
    SdfProduction(sd, _, Attrs(a*)) -> s
  where <?SortDef(s) + ?Cf(SortDef(s))> sd
      ; <not(fetch-elem(?Reject() + ?Bracket()))> a*

  context-free-sort:
    TemplateProduction(SortDef(s), _, Attrs(a*)) -> s
  where <not(fetch-elem(?Reject() + ?Bracket()))> a*

  lexsort-to-scala-decl(|pkg-base*):
    s -> $[// Define implicit conversions (e.g. in the package object) to another representation you prefer
           case class [s](string: java.lang.String, origin: scalaTerms.Origin) extends sdf.Lexical {
             override def toSTerm: STerm.String = STerm.String(string, origin)
           }]
  with pkg := <separate-by(|".");concat-strings> [pkg-base*, "lexicals"]

  sorts-to-scala-decls: (sort*, injection*) -> result
  with result := <map(sort-to-scala-decl(|injection*))> sort*

  sort-to-scala-decl(|injections): sort -> $[sealed trait [sort] extends sdf.Constructor[supers]]
  with supers := <filter(?(<id>, sort)); mapconcat(![" with ", <id>]); concat-strings> injections

  sort-matching-in-scala: (sort*, injection*, constructor*) -> result
  with result := <map(sort-to-companion-object(|injection*, constructor*))
                 ;string-list-join(|"\n")> sort*

  sort-to-companion-object(|injection*, constructor*):
    sort -> <string-list-join(|"\n")>
      [ $<object Extract<sort> extends scalaTerms.Extract[<sort>] {>
      , <string-list-join(|"\n");indent-text(|2)>
        [ $<def unapply(term: STerm): Option[<sort>] = term match {>
        , <string-list-join(|"\n");indent-text(|2)>
          [ match*
          , inj-match*
          , $[case _ => scala.None] ]
        , $[}] ]
      , $[}] ]
  with cons*  := <filter(?(_, FunType(_, ConstType(SortNoArgs(sort)))))> constructor*
     ; match* := <map(constructor-to-STerm-match)> cons*
     ; inj*   := <filter(?(sort, <id>))> injection*
     ; inj-match* := <map(injection-to-STerm-match)> inj*

  lexsort-to-companion-object:
    sort -> <string-list-join(|"\n")>
      [ $<object Extract<sort> extends scalaTerms.Extract[<sort>] {>
      , <string-list-join(|"\n");indent-text(|2)>
        [ $<def unapply(term: STerm): Option[<sort>] = term match {>
        , <indent-text(|2)>
          $[case STerm.String(string, origin) => scala.Some([sort](string, origin))
            case _ => scala.None]
        , $[}] ]
      , $[}] ]

  constructor-to-STerm-match:
    (c, FunType(inputs, ConstType(SortNoArgs(sort)))) ->
      $[case STerm.Cons("[c]", scala.List([match]), o) => scala.Some([sort].[c]([build], o))]
  with match := <map-with-index(type-to-scala-match)
                ;separate-by(|", ")
                ;concat-strings> inputs
     ; build := <map-with-index(\(i, _) -> $[_[i]]\)
                ;separate-by(|", ")
                ;concat-strings> inputs

  injection-to-STerm-match:
    inj-sort -> $[case Extract[inj-sort](_1) => scala.Some(_1)]

  type-to-scala-match: (i, ConstType(SortNoArgs(sort))) -> $[Extract[sort](_[i])]

  type-to-scala-match: (i, ConstType(Sort("List", [SortNoArgs(sort)]))) ->
    $[Extract[sort].list(_[i])]

  type-to-scala-match: (i, ConstType(Sort("Option", [SortNoArgs(sort)]))) ->
    $[Extract[sort].option(_[i])]

  type-to-scala-match: (i, ConstType(Sort(wrapper, [SortNoArgs(sort)]))) ->
    <debug(|"[to-scala-sig] unsupported wrapper type: "); fail> wrapper

  sort-cons-to-scala-decl:
    (sort, cons*) -> <string-list-join(|"\n")>
      [ $[object [sort] {]
      , <indent-text(|2)>
          classes*
      , $[}] ]
  with classes* := <map(cons-to-scala-decl);string-list-join(|"\n")> cons*

  cons-to-scala-decl:
    (c, t) -> $[case class [c]([fields]) extends [super] {
                  override def toSTerm = STerm.Cons("[c]", scala.List([recurseFields]), origin)
                }]
    with FunType(inputs, ConstType(SortNoArgs(super))) := t
       ; fields := <map-with-index(type-to-scala-field)
                   ;![<id>, ["origin: scalaTerms.Origin"]]
                   ;concat
                   ;separate-by(|", ")
                   ;concat-strings> inputs
       ; recurseFields := <map-with-index(\(i, _) -> $[_[i].toSTerm]\)
                          ;separate-by(|", ")
                          ;concat-strings> inputs

  type-to-scala-field: (i, ConstType(SortNoArgs(sort))) -> $[_[i]: [sort]]

  type-to-scala-field: (i, ConstType(Sort("List", [SortNoArgs(sort)]))) ->
    ${_{i}: STerm.List[{sort}]}

  type-to-scala-field: (i, ConstType(Sort("Option", [SortNoArgs(sort)]))) ->
    ${_{i}: sdf.Option[{sort}]}

  type-to-scala-field: (i, ConstType(Sort(wrapper, [SortNoArgs(sort)]))) ->
    <debug(|"[to-scala-sig] unsupported wrapper type: "); fail> wrapper

  string-list-join(|sep) = separate-by(|sep);concat-strings
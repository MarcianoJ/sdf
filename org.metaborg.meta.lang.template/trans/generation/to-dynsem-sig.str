module to-dynsem-sig


imports
  libstratego-lib
  libstrc
  include/TemplateLang
 // utils/contract
  analysis/types
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  lib/ds/signatures/-
  lib/ds/pp/-
  
  generation/to-str
  
  
rules 
	
	module-to-ds-sig:
		Module(Unparameterized(m), i*, s*) -> Module(m',  [is*, Signatures([signatures*])])
		with
			m'  := <conc-strings> ("src-gen/", "ds-signatures/", m, "-sig")
		;   is* := <map(to-str-import(|"-sig", "ds-signatures"))> i*
        ;   signatures* := <filter(section-to-ds-sig)> s*
            
            
    collect-sorts = ?TemplateProduction(SortDef(<id>),_,_) <+ ?TemplateProductionWithCons(SortCons(SortDef(<id>), _), _, _) <+ ?SdfProduction(SortDef(<id>),_,_) <+ ?SdfProductionWithCons(SortCons(SortDef(<id>), _), _, _)
    	    	        	 
	sort-to-ds-sig-sort = !SortDecl(<id>)
	
	section-to-ds-sig:
  	SDFSection(ContextFreeSyntax(p*)) -> Constructors(sig*)
  		where
  		sig* := <filter(cfg-to-ds-sig <+ template-to-ds-sig); not(?[])> p*
	
	section-to-ds-sig:
  	SDFSection(Kernel(p*)) -> Constructors(sig*)
  	where
  		sig* := <filter(cfg-to-ds-sig); not(?[])> p*		
  		
	section-to-ds-sig:
  	SDFSection(Sorts(sorts*)) -> Sorts(ds-sorts*)
  		where
        ds-sorts* := <nub;map(?Sort(<sort-to-ds-sig-sort>))> sorts*
	
  	section-to-ds-sig:
    TemplateSection(t*) -> Constructors(sig*)
    with
      sig* := <filter(template-to-ds-sig); not(?[])> t*	
  			
			
	cfg-to-ds-sig:
    SdfProductionWithCons(SortCons(SortDef(s),c), _, Attrs(a*)) -> <cons-to-ds-decl> c
    where
    	<not(fetch-elem(?Reject() + ?Bracket()))> a*
   
     cfg-to-ds-sig:
    SdfProductionWithCons(SortCons(Cf(SortDef(s)),c), _, Attrs(a*)) -> <cons-to-ds-decl> c
    where
    	<not(fetch-elem(?Reject() + ?Bracket()))> a*	
     	
    cfg-to-ds-sig:
    SdfProductionWithCons(SortCons(Lex(SortDef(s)),c), _, Attrs(a*)) -> <cons-to-ds-decl> c
    where
    	<not(fetch-elem(?Reject() + ?Bracket()))> a* 
   
    template-to-ds-sig:
    TemplateProductionWithCons(SortCons(SortDef(s), c), _, Attrs(a*)) -> <cons-to-ds-decl> c
    where
      <not(fetch-elem(?Reject() + ?Bracket()))> a*  
    	
        
    cons-to-ds-decl:
    Constructor(c) -> ConsDecl(c, rhs*, sort)
    with
      	FunType(rhs-type*, ConstType(SortNoArgs(sort-type))) := <get-type> c;
      	sort := SimpleSort(sort-type);
        rhs* := <map(get-sort-name)> rhs-type*
    
    get-sort-name:     
    ConstType(SortNoArgs(t)) -> SimpleSort(t)
    
    get-sort-name:
    ConstType(Sort("List",[SortNoArgs(s)])) -> ListSort(SimpleSort(s))
    
    check-fun-type: FunType([], t) -> t
    	    

module completions

imports
	include/MiniJava-completions
	editor-common.generated
	new-completions/-
	pp
	runtime/refactoring/-
	runtime/editor/origins

rules
	
	      
      
   expand-placeholder-refactoring:
   	(user-input, selected, position, ast, path, project-path) -> (changes, fatal-errors, errors, warnings)
	with
	  debug(!"input for refactoring : ");
	  suggestions  := <new-iset>;
	  new-node     := <try(suggest-completions(|suggestions))> selected;
	  <iset-elements; debug(!"suggestions ")> suggestions;
	  new-ast*     := <iset-elements; map(\ x -> <at-position(!x|position)> ast \)> suggestions;
	  changes      := <map(!(ast, <id>))> new-ast*;		
	  fatal-errors := [];
      errors       := [];
      warnings     := []    
      
  
   	
   add-completions(|suggestion) = iset-add(|suggestion)
   
   add-list-completions(|suggestion*) = iset-addlist(|suggestion*)
   
   wrap-term(|new-cons) = ?t; !new-cons#(t)
   		
   		
   // inline completions with only one LHS		
   inline-completions(|sort):
	term -> elem
	where
		<not(?sort)> term;
		iset  := <new-iset>;
		<try(suggest-completions(|iset))> term;
		elems := <iset-elements> iset; 
		<?[(desc, elem)]> elems		
	
   
   //inlining completions with two LHS and one is the empty string  
   inline-completions(|sort):
    term -> result
    where
        <not(?sort)> term;
        iset  := <new-iset>;
        <try(suggest-completions(|iset))> term;
        elems := <iset-elements> iset; 
        <?[(desc1, elem1), (desc2, elem2)]> elems;
        if <pp-partial-MiniJava-completions-string; ?""> elem1 then
            result := elem2
        else
            if <pp-partial-MiniJava-completions-string; ?""> elem2 then
                result := elem1
            end
        end
        
     get-proposals:
       (placeholder, ast, cursor-position) -> proposal* 
       where
         suggestion-is := <new-iset>;
         position      := <my-position-of-term(check-placeholder-origin(|placeholder))> ast;
         debug(!"position of term ");
         suggestion*   := <try(suggest-completions(|suggestion-is)); <iset-elements> suggestion-is> placeholder;
         debug(!"suggestions ");
         proposal*     := <map(get-text-from-expand(|ast, position))> suggestion*   
         ; debug(!"proposals ")     

        
    get-text-from-expand(|old-ast, position) :
      (description, expanded-term) -> (description, full-text)
      where
        new-ast           := <at-position(!expanded-term|position)> old-ast;    
        debug(!"new ast");               
        (_, _, full-text) := <construct-textual-change> (old-ast, new-ast)          
        ; debug(!"full text ")
   
        
    get-proposals-list:
     (list, placeholder, ast, cursor-position) -> proposal* 
     where
        suggestion-is := <new-iset>;
        position      := <my-position-of-term(check-placeholder-origin(|list))> ast;
        suggestion*   := <try(suggest-completions(|suggestion-is)); <iset-elements; debug(!"suggestions ")> suggestion-is> placeholder;
        proposal*     := <map(get-text-from-list-insert(|list, cursor-position, position, ast))> suggestion*      
                
    get-text-from-list-insert(|list, cursor-pos, position, ast):
        (description, new-elem) -> (description, full-text)
        where
            debug(!"desc, new-elem ");
            new-list := <add-list-pos(|new-elem, cursor-pos); flatten-list; debug(!"new list ")> list; 
            new-ast           := <at-position(add-list-pos(|new-elem, cursor-pos); flatten-list|position)> ast;
            debug(!"new ast ");
            <pp-partial-MiniJava-completions-string; debug(!"new ast pp")> new-ast;
            (_, _, full-text) := <construct-textual-change; debug(!"textual change ")> (ast, new-ast)
    
    add-list-pos(|new-elem, pos):
        [] -> [new-elem]
                
    add-list-pos(|new-elem, pos):
        list@[h | hs] -> [new-elem | list]            
        where
            debug(!"adding to list before "); 
            (start-offset, end-offset) := <origin-offset> h;
            <debug(!"(pos, (start-offset, end-offset)) ")> (pos, (start-offset, end-offset));
            <geq> (start-offset, pos)
            
    add-list-pos(|new-elem, pos):
        list@[h | hs] -> [h, <add-list-pos(|new-elem, pos)>  hs]            
        where
            debug(!"adding to list after "); 
            (start-offset, end-offset) := <origin-offset> h;
            <debug(!"(pos, (start-offset, end-offset)) ")> (pos, (start-offset, end-offset));
            <geq> (pos, end-offset)         
            
   /* check-list-pos(|pos):
        (new-elem, []) -> <pp-partial-MiniJava-completions-string> new-elem
        
    check-list-pos(|pos):
        (new-elem, list@[h | hs]) ->  <pp-partial-MiniJava-completions-string; correct-indentation(|h)> new-elem
        where
            debug(!"adding to list before "); 
            (start-offset, end-offset) := <origin-offset> h;
            <debug(!"(pos, (start-offset, end-offset)) ")> (pos, (start-offset, end-offset));
            <geq> (start-offset, pos);
            separation := <origin-separation + origin-separation(get-indent, get-separator)> list
            ; debug(!"separation ")
              
    check-list-pos(|pos):
        (new-elem, list@[h | hs]) ->  result
        where
            debug(!"adding to list after ");
            (start-offset, end-offset) := <origin-offset> h;
            <debug(!"(pos, (start-offset, end-offset)) ")> (pos, (start-offset, end-offset));
            <geq> (pos, end-offset);            
            result := <check-list-pos(|pos)> (new-elem, hs)*/
                  
    check-placeholder-origin(|placeholder):
        term -> <id>
        where            
            <?placeholder> term;
            (start-offset-term, end-offset-term)    := <origin-offset; debug(!"origin off-set ")> term; 
            (origin-offset-plhdr, end-offset-plhdr) := <origin-offset; ?(start-offset-term, end-offset-term)> placeholder
            
            
    my-position-of-term(is-term|start-index):
        [] -> <fail>
        
    my-position-of-term(is-term):
        _#(t*) -> <my-position-of-term(is-term|0)> t*
        where
          not(is-term);
          not(?[])

    my-position-of-term(is-term):
        t -> []
        where
          is-term
  
    my-position-of-term(is-term|start-index):
        [t | t*] -> position
        where
          if i* := <my-position-of-term(is-term)> t then
            position := [start-index | i*]
          else
            position := <my-position-of-term(is-term | <inc> start-index)> t*
          end
                        
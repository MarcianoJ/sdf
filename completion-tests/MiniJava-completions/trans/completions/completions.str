module completions

imports
	include/MiniJava-completions
	editor-common.generated
	new-completions/-
	pp
	runtime/refactoring/-
	runtime/editor/origins
	src-gen/pp/-

signature constructors
   Foo : String -> Foo

signature constructors 
   INSERTION_TERM : NewTerm -> AST_CHANGE //Inserting a new term in the completed AST
   REPLACE_TERM   : OldTerm * NewTerm -> AST_CHANGE //Inserting a new term in the completed AST
   
rules
      
   expand-placeholder-refactoring:
   	(user-input, selected, position, ast, path, project-path) -> (changes, fatal-errors, errors, warnings)
	with
	  debug(!"input for refactoring : ");
	  suggestions  := <new-iset>;
	  new-node     := <try(suggest-completions(|suggestions))> selected;
	  <iset-elements; debug(!"suggestions ")> suggestions;
	  new-ast*     := <iset-elements; map(\ x -> <at-position(!x|position)> ast \)> suggestions;
	  changes      := <map(!(ast, <id>))> new-ast*;		
	  fatal-errors := [];
      errors       := [];
      warnings     := []    
   	
   add-completions(|suggestion) = iset-add(|suggestion)
   
   add-list-completions(|suggestion*) = iset-addlist(|suggestion*)
   
   wrap-term(|new-cons) = ?t; !new-cons#(t)
   		   		
   // inline completions with only one LHS		
   inline-completions(|sort):
	term -> elem
	where
		<not(?sort)> term;
		iset  := <new-iset>;
		<try(suggest-completions(|iset))> term;
		elems := <iset-elements> iset; 
		<?[(desc, elem)]> elems			
   
   //inlining completions with two LHS and one is the empty string  
   inline-completions(|sort):
    term -> result
    where
        <not(?sort)> term;
        iset  := <new-iset>;
        <try(suggest-completions(|iset))> term;
        elems := <iset-elements> iset; 
        <?[(desc1, elem1), (desc2, elem2)]> elems;
        if <pp-partial-MiniJava-completions-string; ?""> elem1 then
            result := elem2
        else
            if <pp-partial-MiniJava-completions-string; ?""> elem2 then
                result := elem1
            end
        end    

   find-position: 
      (term, parent) -> index
      where
       args := <get-arguments> parent;
       index := <get-index-origin(|1)> (term, args)
       
   get-index-origin(|idx):
      (term, [h | hs]) -> index
      where       
       (start-offset-term, end-offset-term) := <origin-offset> term;
       (start-offset, end-offset)           := <origin-offset> h;
       if <?(start-offset, end-offset, h)> (start-offset-term, end-offset-term, term) then
            index := idx
       else
            index := <get-index-origin(|<inc> idx)> (term, hs)
       end
       
   get-index-origin(|idx):
      (term, []) -> -1
      
   get-index-cursor-position(|idx):
      (position, [h | hs]) -> index
      where       
       (start-offset, end-offset)           := <origin-offset> h;
       if <leq> (position, start-offset) then
            index := idx
       else
            index := <get-index-cursor-position(|<inc> idx)> (position, hs)
       end
       
   get-index-cursor-position(|idx):
      (position, []) -> idx   
                         
    my-position-of-term(is-term|start-index):
        [] -> <fail>
        
    my-position-of-term(is-term):
        _#(t*) -> <my-position-of-term(is-term|0)> t*
        where
          not(is-term);
          not(?[])

    my-position-of-term(is-term):
        t -> []
        where
          is-term
  
    my-position-of-term(is-term|start-index):
        [t | t*] -> position
        where
          if i* := <my-position-of-term(is-term)> t then
            position := [start-index | i*]
          else
            position := <my-position-of-term(is-term | <inc> start-index)> t*
          end
                        